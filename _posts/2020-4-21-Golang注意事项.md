### Go语言特性
1. Go使用了更加智能的编译器，简化了解决依赖的算法，编译器只会关注那些直接被引用的库，而不是像Java、C和C++一样要遍历依赖链中所有依赖的库，编译速度更快
2. 作为一种静态类型语言，Go提供了类型安全的特性，更容易检查类型错误等bug
3. Go语言中用于并发的goroutine占用的内存远少于线程，并且使用它所需要的代码更少
4. 通道(channel)可以让goroutine之间进行安全的数据通信，可以帮用户避免其他语言里常见的共享内存访问的问题
5. 其他语言如果使用全局变量或共享内存，必须使用复杂的锁规则来防止对同一个变量的不同步修改。通道可以保证同一时刻只会有一个goroutine修改数据
6. Go提供了灵活的、无继承的类型系统，依然支持面向对象开发。在Go中，一个类型由其他更微小的类型**组合**而成，避免了传统的基于继承的模型
7. Go还具有独特的接口实现机制，允许用户对行为进行建模，而不是对类型进行建模，用户不需要声明某个类型实现了某个接口，编译器会判断一个类型的实例是否符合正在使用的接口
8. Go语言的接口更小，只倾向于定义一个单一的动作，更有利于使用组合来复用代码
9. Go语言拥有现代化的垃圾回收机制，显著降低了开发难度

### Go开发注意事项
1. 每个可执行的Go程序都有两个明显的特征，一个是作为程序入口的main函数，第二个是包含main函数的包名main。如果main函数不在main包里，构建工具不会生成可执行的文件
2. Go语言的每个代码文件都属于一个包，一个包定义一组编译过的代码，类似于命名空间，可以把不同包中定义的同名标识符区别开
3. 所有处于同一个文件夹内的代码文件必须使用同一个包名，按照惯例，包和文件夹同名
4. 导入包时使用下划线是为了让Go语言对包做初始化操作，但是并不使用包里的标识符，因为Go不允许声明导入某个包但是不使用，下划线让编译器接受这类导入并且调用对应包里的所有代码文件里定义的init函数
5. 程序中的每个代码文件里的init函数都会在main函数执行前调用
6. 从标准库中导入代码时只需要给出要导入的包名，编译器总是会到GOROOT和GOPATH环境变量引用的位置去查找
7. Go语言包里公开的标识符以大写字母开头，不公开的标识符以小写字母开头，不公开的标识符不能被其他包里的代码直接访问，但是可被间接访问
8. Go语言中所有变量都被初始化为其零值，对于map、slice等引用类型，所引用的底层数据结构会被初始化为其对应的零值，但是被声明为其零值的引用类型的变量，会返回nil作为其值
9. 通道与映射(map)和切片(slice)一样都是引用类型，不过通道本身实现的是一组带类型的值，这组值用于在goroutine之间传递数据
10. Go语言中如果main函数返回，整个程序也就终止，程序终止时还会关闭所有值钱启动且还在运行的goroutine，因此在编写并发程序时最佳做法是在main函数返回前清理并终止所有值钱启动的goroutine
11. Go语言中可以使用sync包的WaitGroup跟踪所有启动的goroutine，这是一个信号量，可以利用它来统计所有的goroutine是不是都完成了工作
12. 如果要调用的函数返回多个值，而又不需要其中的某个值，就可以使用下划线标识符将其忽略掉。
13. 查找map里的键时，要么赋值给一个变量，要么赋值给两个变量。赋值给两个变量时第一个值和赋值给第一个变量时的值一样，是map查找的结果值，如果指定了第二个值就会返回一个布尔标志来表示查找的键是否存在于map里。如果这个键不存在，map会返回其零值作为返回值，若存在则返回其副本
14. Go语言中所有的变量都以值的方式传递，指针变量可以方便地在函数之间共享数据，使用指针变量可以让函数访问并修改一个变量的状态
15. Go语言支持闭包，可以直接访问到那些没有作为参数传递的变量，闭包技术通过直接访问外层作用域的变量本身来进行访问。因为在循环迭代过程中不宜使用闭包，因为随着外层函数变量的改变，内层函数也会感知到这些改变，所有的goroutine都会因为闭包共享同样的变量
16. Go编译器可以根据赋值运算符右边的值来推导类型，因此声明常量时不需要指定类型
17. 解析JSON格式文档定义结构体类型时，每个字段声明的最后\`引号里的部分被称作标记(tag)，这个标记里描述了JSON解码的元数据，每个标记将结构类型字段对应到JSON文档里指定名字的字段
18. 关键字defer会安排随后的函数调用在函数返回时才执行。哪怕函数意外崩溃终止，也能保证关键字defer安排调用的函数会被执行
19. 命名接口时，如果接口类型只包含一个方法，那么按照Go语言的命名惯例，这个类型的名字以er结尾
20. 空结构在创建实例时不会分配任何内存，这种结构很适合创建没有任何状态的类型
21. 声明方法中的接受者时，如果为值本身，则可以通过值或者指向这个类型值的指针来调用该方法，因为编译器都会正确地引用或解引用对应的值
22. 大部分方法在被调用后都需要维护接收者的值的状态，所以最佳实践是将方法的接收者声明为指针
23. 使用指针作为接收者的方法，只能在接口类型是指针的时候被调用，使用值作为接收者声明的方法，在接口类型的值为值或者指针时都可以被调用
24. 满足接口的类型的值和指针都可以作为接口类型的值，赋值和传递给接受接口类型值的函数