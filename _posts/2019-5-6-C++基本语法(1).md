### C++类型转换
1. const_cast:用于将const变量变为非const
2. static_cast：用于各种隐式转换，比如非const转const，void*转指针等，static_cast能用于多态向上转化（派生类转基类），如果向下转（基类转派生类）能成功但是不安全并且结果未知
3. dynamic_cast：用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用，向下转换（基类转派生类）时，如果是非法的对于指针返回NULL，对于引用抛异常。它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否进行向下转换。
4. reinterpret_cast：几乎什么都可以转，比如将int转指针，本质上依赖机器可能会出问题，尽量少用。
5. 用C++这四种而不用C的强制类型转换，主要是因为C的强制类型转换表面上看起来功能强大什么都能转但是转换不够明确，不能进行错误检查，容易出错。

### C/C++中指针和引用的区别
1. 指针有自己的一块空间，而引用只是别名
2. 使用sizeof可知32位机器中一个指针的大小为4字节，而引用则是被引用对象的大小
3. 指针可以被初始化为nullptr空指针，但是引用必须被初始化且必须是一个已有对象的引用
4. 作为参数传递，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会直接改变引用所指向的对象
5. 可以有const指针，但是没有const引用
6. 指针在使用中可以指向其他对象，但是引用只能是一个对象的引用，不能被改变
7. 指针可以有多级指针（**p），而引用只有一级
8. 指针和引用使用++运算符的意义不一样
9. 如果返回动态内存分配的对象或者内存必须使用指针，引用可能引起内存泄漏

### C++中的智能指针
1. C++11后有四个智能指针：auto_ptr、shared_ptr、weak_ptr、unique_ptr，其中C++11之后将auto_ptr弃用。智能指针的作用在于管理裸指针，因为使用裸指针申请动态内存可能会出现申请的空间在函数结束时忘记释放，造成内存泄露的情况。使用智能指针由于智能指针本质上是类，当超出了智能指针类的作用域时会自动调用其析构函数自动释放资源。
2. auto_ptr拥有独占性资源但是可以将其资源赋给其他auto_ptr编译器不会报错，因此存在潜在的内存崩溃问题，而后续的unique_ptr弥补了这一问题
3. unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象，对于避免资源泄露特别有用，并且由于其复制构造函数和复制赋值函数均为delete函数因此不能用一个unique_ptr来初始化另一个unique_ptr或者赋给另外一个（临时右值unqiue_ptr除外）。
    ```
    int x=1;
    unqiue_ptr<int> p1=make_unique(x);
    auto p2=p1;                      //报错
    unqiue_ptr<int> p3(new int(1));  //不报错
    ```
4. 使用std::move移动操作可以把一个裸指针的所有权从一个unqiue_ptr转移到另一个unqiue_ptr。
5. shared_ptr实现共享式拥有概念，多个shared_ptr可以指向同一对象，该对象和相关资源会在“最后一个引用被销毁”的时候释放，使用计数机制来表明资源被几个指针共享，可以通过成员函数use_count()来查看计数。shared_ptr除了通过new来构造，还可以通过传入unique_ptr、weak_ptr来构造，调用reset当前指针会释放资源所有权，计数减一，当计数==0时资源会被释放。
6. weak_ptr不控制对象生命周期，指向一个shared_ptr管理的对象，只是提供了对管理对象的一个访问手段。weak_ptr设计的目的是配合shared_ptr而引用的一种智能指针来协助weak_ptr工作，只可以从一个shared_ptr或者另一个weak_ptr对象构造。weak_ptr的创建和销毁都不会改变引用计数。weak_ptr是用来解决shared_ptr相会引用时的死锁问题，因为两个shared_ptr如果相互引用则这两个指针的引用计数永远不会下降为0，资源永不释放。
7. 我们不能直接通过weak_ptr直接访问对象，而是得调用lock()成员函数将weak_ptr转换为shared_ptr然后再访问。
8. C/C++中的野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针。
9. 智能指针也存在内存泄露的情况，当两个对象互相使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。解决方法就是使用weak_ptr来指向对方。

### 类成员函数及函数指针相关问题
1. 基类的析构函数设置成虚函数的原因是将可能会被继承的父类中的析构函数设置成虚函数，可以保证我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。
2. C++默认的析构函数不设置成虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时才设置为虚函数。
3. 函数指针是指向函数的指针变量，C/C++在编译时每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址，有了指向函数的指针变量后可用该指针调用函数，就如同用指针变量可引用其他类型变量一样。
4. 函数指针可用于调用函数和做函数的参数，比如回调函数。
5. 



