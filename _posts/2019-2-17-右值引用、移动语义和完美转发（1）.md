### 理解std::move和std::forward
1. 移动语义使得编译器得以使用不那么昂贵的移动操作，来替换昂贵的复制操作。移动语义也使得创建只移类型对象成为可能，这些类型包括std::unique_ptr和std::future和std::thread等。
2. 完美转发使得人们可以撰写接受任何实参的函数模板，并将其转发到其他函数，目标函数会接受到与转发函数所接受的完全相同的实参。
3. 形参总是左值，即使其类型是右值引用。比如`void f(Widget&& w);`，形参w是个左值，即使它的类型是个指向Widget类型对象的右值引用。
4. std::move并不进行任何移动，std::forward也不进行任何转发。它俩都是仅仅执行强制类型转换的函数（其实就是函数模板），std::move无条件地将实参强制转换成右值，而std::forward则仅在某个特定条件满足时才执行同一个强制转换。std::move将实参强制转换成了右值，这就是该函数的全部所作所为。
5. 由于右值是可以移动的，所以在一个对象上实施了std::move就是告诉编译器该对象具备可移动的条件，它简化了对象是否可移动的表述。
6. 为了维持常量正确性，C++不允许常量对象传递到有可能改动它们的函数（例如移动构造函数）而指向常量的左值引用允许绑定一个指向右值类型的实参，因此通常会调用复制构造函数而非移动构造函数。
7. 如果想取得对某个对象执行移动操作的能力，则不要将其声明为常量，因为针对常量对象执行的移动操作将一声不响地变换成复制操作。std::move不仅不实际移动任何东西，甚至不保证经过其强制类型转换的对象具备可移动能力（对象为常量即不可移动）。
8. std::forward是一个有条件的强制类型转换，其最常见使用场景就是某个函数模板使用了万能引用类型为形参，随后将其传递给另一个函数。由于所有形参都是左值，std::move提供了一种机制，当且仅当用来初始化形参的实参是个右值的条件下把形参强制转换成右值类型，这就是std::move干的一切。
9. 当传入实参为左值时，std::forward并不会进行强制类型转换，所以我们通常在构造移动构造函数时需要用到std::move，而不是std::forward。