### vector
1. vector与array的唯一区别在于空间的运用的灵活性，array是静态空间，一旦配置了就不能改变，vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素
2. vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率。
3. vector维护的是一个连续线性空间，支持随机存取，因此vector提供的是随机存取的迭代器，它以两个迭代器start和finish分别指向目前使用空间的头和尾，并以迭代器end_of_storage指向目前可用空间的尾端
4. 一个vector的容量(capacity)永远大于或等于其大小，一旦容量等于大小就是满载，下次再有新增元素，整个vector就得重新分配内存重新复制
5. vector的动态增加大小并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此对于vector的任何操作一旦引起空间重新配置，指向原vector的所有迭代器都会失效
6. vector的`erase(first,last)`操作是将last之后的元素copy覆盖到first之后的位置，然后再把copy函数返回的迭代器位置到finsh迭代器之间的所有元素destroy即可，`erase(position)`也是这样的实现方式
7. vector在实现`insert(pos,n,x)`时，如果备用空间大于等于n的话，当pos之后的元素数量大于n时，使用`uninitialized_copy`函数将finish之前的n个元素后移，然后在使用`copy_backward`函数将pos之后剩余的元素右移，最后使用`fill`函数填充新元素
8. 当pos之后的元素小于n时，先将`n-(finish-pos)`个元素构造于finish位置，然后将原先pos之后的元素都使用`uninitialized_copy`函数置于这些构造新元素之后，然后再将pos与原先finish迭代器之间的位置用x来填充
9. 当备用空间小于n时，vector会先配置新空间，然后依次将pos之前的元素、新增的n个元素以及pos之后的元素拷贝到新的内存空间