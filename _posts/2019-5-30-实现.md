### 尽可能延后变量定义式的出现时间
1. 变量定义时我们需要付出构造成本，变量离开作用域时我们需要承担析构成本。因此如果不是确定使用变量就将变量定义式往后放。
2. 我们不仅需要延后变量的定义，直到非得使用该变量的前一刻，还应该尝试延后这份定义直到能够给它初值实参为止。这样不仅可以避免构造和析构非必要对象，还可以避免无意义的default构造行为。
3. 如果我们知道赋值成本比“构造+析构”成本低，并且正在处理代码中效率高度敏感的部分，那我们可以将变量定义在循环外，否则我们应该将其定义在循环内。

### 尽量少做转型动作
1. C风格的转型动作：(T)expression   //将expression转为T  
函数风格的转型动作：T(expression)    //将expression转型为T
2. C++的转型操作：const_cast、dynamic_cast、static_cast、reinterpret_cast。新式转型比较受欢迎原因在于：很容易被辨识并且各个转型动作的目标愈窄化，编译器愈可能诊断出错误的运用。
3. 转型后得到的是新的副本而不是对原来的对象就行修改，并且转型操作的实现执行速度可能会很慢，效率不高。因此如果可以，尽量避免转型，特别是在注重效率的代码中避免使用dynamic_cast。
4. 如果转型是必要的，试着将它隐藏在某个函数的背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码中。
5. 宁可使用C++新式转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职责。

### 避免返回handles指向对象内部成分
1. 引用、指针和迭代器统统都是所谓的handles（用来取得某个对象），而返回一个“代表对象内部数据”的handle，随之而来的就是“降低对象封装性”的风险。
2. 如果返回一个handle，用户就可以取得一个指针、引用或迭代器指向我们封装内的成员，然后通过handle调用它。
3. 避免返回handles（包括引用、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生空悬指针、空悬引用以及空悬迭代器的可能性降至最低。

### 为“异常安全”而努力是值得的
1. 当异常被抛出时，带有异常安全性的函数会：  
（1）不泄露任何资源，比如内存或mutex资源未释放  
（2）不允许数据败坏，比如将指针指向new异常的对象
2. 解决资源泄露的问题我们可以使用资源管理类，利用C++中对象生命周期结束会自动调用析构函数的特性来释放资源，因此主要问题在于数据败坏的问题。
3. 异常安全函数提供以下三个保证之一：  
（1）基本承诺：异常被抛出时程序内的任何事物仍然保持在有效状态下，没有对象或数据结构会因此而败坏，但是程序的现实状态恐怕不可预料  
（2）强烈保证：异常被抛出，程序状态不改变，调用函数时如果调用失败就回到调用函数之前的状态  
（3）不抛掷保证：承诺绝不发生异常，作用于内置类型（比如int，指针等）身上的操作都提供nothrow保证。
4. 我们自己编写的代码特别是运用到动态内存的地方很难达到不抛掷保证。copy and swap策略很典型导致强烈保证，原则很简单：为你打算修改的对象做出一份副本，然后在副本上做一切必要的修改，若有任何异常抛出，此时对象状态也未改变，待改变成功后再将对象与修改完的副本在一个不抛出异常的操作中置换（swap）。
5. 如果函数只操作局部性状态，便相对容易地提供强烈保证，但是当函数对“非局部性数据”有连带影响时，提供困难保证就困难得多。
6. copy and swap问题在于为每个需要修改的对象作出一个副本，可能会带来比较大的空间和时间开销，因此当强烈保证不切实际时，我们必须提供“基本保证”。
7. 函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。