### 尽可能延后变量定义式的出现时间
1. 变量定义时我们需要付出构造成本，变量离开作用域时我们需要承担析构成本。因此如果不是确定使用变量就将变量定义式往后放。
2. 我们不仅需要延后变量的定义，直到非得使用该变量的前一刻，还应该尝试延后这份定义直到能够给它初值实参为止。这样不仅可以避免构造和析构非必要对象，还可以避免无意义的default构造行为。
3. 如果我们知道赋值成本比“构造+析构”成本低，并且正在处理代码中效率高度敏感的部分，那我们可以将变量定义在循环外，否则我们应该将其定义在循环内。

### 尽量少做转型动作
1. C风格的转型动作：(T)expression   //将expression转为T  
函数风格的转型动作：T(expression)    //将expression转型为T
2. C++的转型操作：const_cast、dynamic_cast、static_cast、reinterpret_cast。新式转型比较受欢迎原因在于：很容易被辨识并且各个转型动作的目标愈窄化，编译器愈可能诊断出错误的运用。
3. 转型后得到的是新的副本而不是对原来的对象就行修改，并且转型操作的实现执行速度可能会很慢，效率不高。因此如果可以，尽量避免转型，特别是在注重效率的代码中避免使用dynamic_cast。
4. 如果转型是必要的，试着将它隐藏在某个函数的背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码中。
5. 宁可使用C++新式转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职责。

### 避免返回handles指向对象内部成分
1. 引用、指针和迭代器统统都是所谓的handles（用来取得某个对象），而返回一个“代表对象内部数据”的handle，随之而来的就是“降低对象封装性”的风险。
2. 如果返回一个handle，用户就可以取得一个指针、引用或迭代器指向我们封装内的成员，然后通过handle调用它。
3. 避免返回handles（包括引用、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生空悬指针、空悬引用以及空悬迭代器的可能性降至最低。

### 为“异常安全”而努力是值得的
1. 