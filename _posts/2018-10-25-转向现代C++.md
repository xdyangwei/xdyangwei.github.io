## 转向现代C++

### 创建对象时注意区分()和{}

1. 大括号初始化可以用来指定容器的初始内容，也可以用来为非静态成员指定默认初始化值（此时使用=号初始化也可行，但不能使用小括号）。

2. 不可复制的对象（std::atomic等类型对象）可以使用大括号和小括号来进行初始化，却不能使用“=”。在大括号、小括号和=三种初始化表达式写法中只有大括号适用于所有场合。

3. 大括号初始化的一项新特性是禁止内建类型之间进行隐式窄化类型转换，如果大括号内的表达式无法保证能够采用进行初始化的对象来表达，则代码不能通过编译，比如：

   ```c++
   double x,y,z;
   int sum1{x+y+z};//错误！double类型之和可能无法用int表达
   ```

   而采用小括号和=号的初始化则不会进行窄化类型检查，因为会破坏太多遗留代码。

### 优先使用nullptr，而非0或NULL

1. 字面常量0的类型是int，而非指针，当C++在只能使用指针的语境中发现了一个0，它也会勉强解释为空指针，但说到底还是一个不得已而为之的行为。以上结论对于NULL也成立，0和NULL都不具备指针类型。因此，在指针类型和整数类型之间重载时可能会发生意外。
```
void f(int);
void f(bool);
void f(void*);
f(0);//调用的是f(int),而不是f(void*)
f(NULL);//可能不通过编译，但一般会调用f(int)。从来不会调用f(void*)
```
2. nullptr的优点在于它不具备整型类型，实话实话它也不具备指针类型，它的实际类型是`std::nullptr_t`，可以隐式转换为所有的裸指针类型。并且使用nullptr可以提升代码的清晰性。
3. 在函数模板中传入0或者NULL会被模板自动推导为是int整型，而如果此时需要指针类型就会编译不通过，而使用nullptr就不会出现这种问题。
4. **因此，想要表示空指针时，使用nullptr而非0或NULL，另外避免在整型和指针类型之间重载。**

### 优先使用别名声明，而非typedef

1. 别名声明可能在处理涉及函数指针的时候比较容易理解：
```
typedef void (*FP)(int,const std::string&);//FP类型是一个指向形参为int和const std::string&,
using FP=void (*)(int,const std::string&);//没有返回值的函数指针
```
2. 别名声明可以模板化（这种情况下它们被称为别名模板，alias template），typedef就不行。另外如果想要在模板内使用typedef来创建一个链表，它容纳的对象类型由模板形参指定的话，那你就要给typedef的名字加一个typename前缀。依赖于模板类型形参(T)的类型::type称为带依赖类型，而C++规定带依赖类型前必须加上typename。而使用别名的话就不会产生带依赖类型。
3. 别名模板可以让人免写”::type“后缀，并且在模板内，对于内嵌typedef的引用经常要求加上typename前缀。

### 优先选用限定作用域的枚举类别，而非不限作用域的枚举类型

1. 如果在一对大括号里声明一个名字，则该名字的可见性就被限定在括号括起来的作用域内。但是这个规则不适用于C++98风格的枚举类型中定义的枚举量。
```
enum Color{black,white,red};//black、white、red所在作用域和Color相同
auto white=false;//错误，white已在范围内声明过了
```
2. 上述枚举类型被称为不限范围的枚举类型，而C++11中有限定作用域的枚举类型。
```
enum class Color{black,white,red};//三个元素被限定在了Color中
auto white=false;//没问题
```
3. 不限范围的枚举类型中的枚举量可以隐式转换到整数级别（并能够进一步转换到浮点类型），而限定作用域的枚举类型到任何其他类型都不存在隐式转换路径。
4. 限定作用域的枚举类型可以进行前置声明，而不限作用域的则不行。
```
enum Color;//错误
enum class Color;//正确
```
这是因为限定作用域的枚举类型的底层类型是已知的，而不限范围的枚举类型的底层类型，我们可以进行指定。当我们指定过后，不限范围的枚举类型也能够进行前置声明了。限定作用域的默认底层类型是int。
5. 枚举类型的底层类型可以通过std::underlying_type::type(C++11)或者std::underlying_type_t(C++14)来取得。

### 优先使用删除函数，而非private未定义函数

1. 为了让输入输出流类成为不可复制的，在C++98中将他们的拷贝构造函数和拷贝赋值函数都声明为private，这就阻止了客户去调用他们，并且故意不去定义它们，这就阻止了友元或者其他成员函数调用它们。
2. 在C++11中，使用“=delete”将拷贝构造函数和拷贝赋值函数都标识为删除函数，是达成相同效果的更好途径。删除函数无法通过任何方式使用，因此友元或是成员函数也会因试图复制类对象而无法工作，而在C++98中这种不当使用要到链接阶段才能诊断出来。
3. 将删除声明为public而非private能得到更好的错误信息。删除函数的另一个优点在于：任何函数都能声明为delete，但是只有成员函数能被声明为private。因此重载函数并定义为删除函数能够帮我们阻止编译器所带来的隐式类型转换。
```
bool islucky(int number);
islucky(100);//right
islucky('a');//将‘a’转换为其ascii码在判断。也没错
islucky(3.5);//double类型截断后再调用也没错
bool islucky(char)=delete;//此时islucky('a')调用就会出错
```
4. 删除函数的另一作用而private做不到的就是可以阻止那些不应该的模板具现（模板特例化）。
```
template<typename T>void processPointer(T* ptr);
template<> 
void processPointer(void* ptr)=delete;//这样就阻止了使用void*来特例化此模板
```

### 为意在改写的函数添加override声明

1. 正是虚函数改写，使得通过基类接口调用派生类函数成了可能。成员函数改写需要满足要求：  
基类中的函数必须是虚函数，基类和派生类中的函数名字、形参类型、函数常量性必须完全相同（析构函数除外），基类和派生类的函数返回值和异常规格必须兼容（C++98）  
more:基类和派生类的函数引用饰词必须完全相同，引用饰词是为了实现限制成员函数仅用于左值或右值。带有引用饰词的函数不一定是虚函数（C++11）。
2. 由于对于声明派生类中的改写，保证正确性很重要，而出错又很容易，C++11提供了一种方法来显式地标明派生类中的函数是为了改写基类版本：为其加上override声明。这样不止让编译器在你想要改写的函数实际上未改写时提醒你，还可以在打算更改基类中的虚函数的签名时，衡量一下波及的影响面。
3. override这类语境关键词仅于出现在成员函数的声明的末尾时才有保留意义，其余地方并没有“改写”的意义。而另一个语境关键词就是final，将final应用于虚函数，会阻止它在派生类中被改写，final也可以用于一个类，禁止该类用作基类。
4. 成员引用饰词使得对于左值和右值对象(*this)的处理能够区分开来。

### 优先使用const_iterator,而非iterator

1. 