## 转向现代C++

### 创建对象时注意区分()和{}

1. 大括号初始化可以用来指定容器的初始内容，也可以用来为非静态成员指定默认初始化值（此时使用=号初始化也可行，但不能使用小括号）。

2. 不可复制的对象（std::atomic等类型对象）可以使用大括号和小括号来进行初始化，却不能使用“=”。在大括号、小括号和=三种初始化表达式写法中只有大括号适用于所有场合。

3. 大括号初始化的一项新特性是禁止内建类型之间进行隐式窄化类型转换，如果大括号内的表达式无法保证能够采用进行初始化的对象来表达，则代码不能通过编译，比如：

   ```c++
   double x,y,z;
   int sum1{x+y+z};//错误！double类型之和可能无法用int表达
   ```

   而采用小括号和=号的初始化则不会进行窄化类型检查，因为会破坏太多遗留代码。
### 优先使用nullptr，而非0或NULL
1. 字面常量0的类型是int，而非指针，当C++在只能使用指针的语境中发现了一个0，它也会勉强解释为空指针，但说到底还是一个不得已而为之的行为。以上结论对于NULL也成立，0和NULL都不具备指针类型。因此，在指针类型和整数类型之间重载时可能会发生意外。
```
void f(int);
void f(bool);
void f(void*);
f(0);//调用的是f(int),而不是f(void*)
f(NULL);//可能不通过编译，但一般会调用f(int)。从来不会调用f(void*)
```
2. nullptr的优点在于它不具备整型类型，实话实话它也不具备指针类型，它的实际类型是`std::nullptr_t`，可以隐式转换为所有的裸指针类型。并且使用nullptr可以提升代码的清晰性。
3. 在函数模板中传入0或者NULL会被模板自动推导为是int整型，而如果此时需要指针类型就会编译不通过，而使用nullptr就不会出现这种问题。
4. **因此，想要表示空指针时，使用nullptr而非0或NULL，另外避免在整型和指针类型之间重载。**
### 优先使用别名声明，而非typedef
1. 别名声明可能在处理涉及函数指针的时候比较容易理解：
```
typedef void (*FP)(int,const std::string&);//FP类型是一个指向形参为int和const std::string&,
using FP=void (*)(int,const std::string&);//没有返回值的函数指针
```
2. 别名声明可以模板化（这种情况下它们被称为别名模板，alias template），typedef就不行。另外如果想要在模板内使用typedef来创建一个链表，它容纳的对象类型由模板形参指定的话，那你就要给typedef的名字加一个typename前缀。依赖于模板类型形参(T)的类型::type称为带依赖类型，而C++规定带依赖类型前必须加上typename。而使用别名的话就不会产生带依赖类型。
3. 别名模板可以让人免写”::type“后缀，并且在模板内，对于内嵌typedef的引用经常要求加上typename前缀。
### 优先选用限定作用域的枚举类别，而非不限作用域的枚举类型
1. 如果在一对大括号里声明一个名字，则该名字的可见性就被限定在括号括起来的作用域内。但是这个规则不适用于C++98风格的枚举类型中定义的枚举量。
```
enum Color{black,white,red};//black、white、red所在作用域和Color相同
auto white=false;//错误，white已在范围内声明过了
```
2. 上述枚举类型被称为不限范围的枚举类型，而C++11中有限定作用域的枚举类型。
```
enum class Color{black,white,red};//三个元素被限定在了Color中
auto white=false;//没问题
```
3. 不限范围的枚举类型中的枚举量可以隐式转换到整数级别（并能够进一步转换到浮点类型），而限定作用域的枚举类型到任何其他类型都不存在隐式转换路径。
4. 限定作用域的枚举类型可以进行前置声明，而不限作用域的则不行。
```
enum Color;//错误
enum class Color;//正确
```
这是因为限定作用域的枚举类型的底层类型是已知的，而不限范围的枚举类型的底层类型，我们可以进行指定。当我们指定过后，不限范围的枚举类型也能够进行前置声明了。限定作用域的默认底层类型是int。