### 裸指针存在的问题
1. 裸指针在声明时并没有指出所指向的是单个对象还是数组
2. 裸指针声明时没有提示在使用完指向的对象后是否需要析构它。我们无法从声明中看出指针是否拥有其指向的对象
3. 即使需要析构，由于不清楚其指向单个对象还是数组，也不知道该如何析构它，该使用delete还是delete[]或是其它专门的析构函数中。
4. 我们需要保证所有指针的析构执行并且只执行一次，因为不执行析构就会导致资源泄露，多次执行则会产生未定义行为。
5. 我们无法检测出一个指针是否是空悬指针，即所指向的对象已被析构。
6. 为了解决这一问题，因此C++11引入了智能指针，unique_ptr用以取代C++98中的auto_ptr，只有当使用C++98编译器时我们才使用auto_ptr，其余地方auto_ptr都可以用uniqu_ptr代替。

### 使用std::unique_ptr管理具备专属所有权的资源

1. 当我们需要使用智能指针时，unique_ptr基本上是首选，因为它和裸指针有着相同的尺寸，并且对于大多数的操作都执行了相同的指令。
2. 一个非空的unique_ptr总是拥有其所指向的对象和资源，移动一个unique_ptr会将所有权从源指针移至目标指针，同时unique_ptr不允许复制因为要是允许复制那么就会有两个unique_ptr指向同一对象，不符合unique_ptr的性质。
3. 默认unique_ptr指向对象的析构是调用内部裸指针的delete操作完成的。
4. unique_ptr的一个常见用法是在对象继承谱系中作为工厂函数的返回类别。
5. 我们可以设置使用自定义析构器：析构资源时所调用的任意函数（或函数对象，包括那些由lambda表达式产生的）。所有自定义删除函数都接受一个指向欲析构对象的裸指针，然后采取必要措施析构该对象，使用lambda表达式创建一个删除函数很方便。
6. 要使用自定义析构器时，其类别必须被指定为unique_ptr的第二个实参，也就是自定义删除函数的类别。
7. 将一个裸指针赋给unique_ptr是编译不过的，因为这样会造成从裸指针到智能指针的隐式转换，这种隐式转换大有问题，因此需要reset来指定让unique_ptr获取new运算符产生的对象的所有权。
8. 在使用默认析构器（delete函数）的前提下，unique_ptr与裸指针尺寸相同，但是使用自定义析构器时就不一样了，析构器是函数指针的话尺寸往往增加1到2个字长(word)，如果是函数对象则尺寸变化取决于该函数对象中存储的状态，而无状态的函数对象（如无捕获的lambda表达式）不会浪费任何尺寸，因此使用lambda表达式实现自定义析构函数往往是个更好的选择。
9. unqiue_ptr以两种形式提供，一种是单个对象(std::unqiue_ptr<T>，一种是数组(std::unqiue_ptr<T[]>)，但是使用容器字符串等几乎总是比裸数组更好，因此很少使用。
10. std::unqiue_ptr还能高效的转换为std::shared_ptr。

### 使用std::shared_ptr管理具备共享所有权的资源

1. 没有哪个特定的shared_ptr拥有其指向的对象，所有指向其的所有shared_ptr共同协作，当最后一个指向该对象的shared_ptr不再指向它时，该shared_ptr会析构其指向的对象。
2. shared_ptr用访问某资源的引用计数，即指向该资源的shared_ptr数量来确定自己是否是最后一个指向该资源的shared_ptr。shared_ptr构造函数会让该计数递增，析构函数会让该计数递减。
3. 复制赋值操作符`sp1=sp2`会递减sp1原指向对象的引用计数，递增sp2指向对象的引用计数。如果某个shared_ptr析构完发现递减完后引用计数变为0，shared_ptr会析构其指向的资源。
4. 引用计数的存在将会带来一些性能影响：  
（1）shared_ptr的尺寸是裸指针的两倍，既包含裸指针也包含指向该资源的引用计数的裸指针  
（2）引用计数的内存必须动态分配，shared_ptr若是使用std::make_ptr创建可避免动态分配的成本，但是有些场景无法使用make_ptr。但是无论使不使用make_ptr引用计数都会作为动态分配的数据来存储。  
（3）引用计数的递增和递减必须是原子操作，因为不同线程可能会发生并发的读写器，原子操作一般比非原子操作慢。
5. 移动shared_ptr不会发生引用计数递增操作，而复制则需要，因此移动会比复制操作快，这一点对于构造和赋值操作都成立。
6. shared_ptr默认析构器依然是delete，也支持自定义析构器，但是对于unique_ptr来说，析构器类型是其类型的一部分，当两个unique_ptr存储相同类型的裸指针但不同类型的析构器时他们不是一个类型，而对于shared_ptr来说析构器类型并不是其类型的一部分，当二者裸指针类型相同析构器类型不同时也可以认为是同一个类型。
7. 并且与unique_ptr不同的是自定义析构器类型不会影响其尺寸大小。每一个由shared_ptr管理的对象都有一个控制块除了包含引用计数外还包含自定义析构器的一个复制，如果该自定义析构器被指定的话，如果指定了一个自定义内存分配器控制块也会包含一份它的复制，控制块还可能包含其他附加数据，比如弱引用计数等。
8. 一个对象的控制块由创建首个指向该对象的shared_ptr的函数来确定，而控制块的创建遵循以下规则：  
（1）std::make_shared总是创建一个控制块，make_shared会生产出一个用以指向的对象，因此调用make_shared时不会有该对象的控制块存在  
（2）从具备专属所有权的指针（即auto_ptr或unique_ptr）出发构造一个shared_ptr指针时也会创建一个控制块  
（3）当shared_ptr构造函数使用裸指针作为实参调用时，它会创建一个控制块。