### 整数与浮点数
1. Go的数据类型分四大类：基础类型、聚合类型、引用类型和接口类型。基础类型包括数字、字符串和布尔型
2. `rune`类型是int32类型的同义词，常用于指明一个值是Unicode码点，这两个名称可互换使用。`byte`类型同样是int8类型的同义词，强调一个值是原始数据而非量值
3. 有符号整数以补码表示，保留最高位为符号位，n位数字的取值范围为-2<sup>n-1</sup>~2<sup>n-1</sup>-1,无符号整数由全部位构成其非负值，范围是0~2<sup>n</sup>-1
4. Go中取模整数运算符%仅能用于整数，取模余数的正负号总是与被除数一致，除法运算的行为取决于操作数是否都为整型
5. 运算符`^`作为二元运算符为异或，作为一元运算符则为按位取反，运算符`&^`是按位清除：表达式`z=x&^y`中，若y的某位为1，则z的对应位为0，否则等于x的相应位
6. 左移以0填补右边空位，无符号整数右移同样以0填补左边空位，有符号整数右移是按符号位的值填补空位
7. 如果使用fmt包输出数字，我们可以使用谓词%d、%o和%x指定进位制基数和输出格式。通常Printf的格式化字符串含有多个%谓词，这要求提供相同数量的操作数，而%后的谓词`[1]`告知Printf重复使用第一个操作数，而%o、%x或%x之前的副词`#`告知Printf输出相应的前缀0、0x或0X
8. 用%c输出文字符号，如果希望输出带有单引号则用%q
9. 浮点数能方便地通过谓词%g输出，该谓词会自动保持足够的精度，并选择最合适的表示方式，但是对于数据表。%e（有指数）和%f（无指数）的形式可能更合适，这三个谓词都能掌控输出宽度和数值精度
10. 所有数字包括NaN自身与NaN的比较总不成立（除了!=，它总是与==相反）
11. Go具备两种大小的复数complex64与complex128，二者分别由float32与float64构成，内置的complex函数根据给定的实部和虚部创建复数，而内置的real函数和imag函数则分别提取复数的实部或虚部。在浮点数或十进制整数后面紧接着写字母i，它就变成了一个虚数
12. bool型的值或布尔值（boolean）只有两种可能：true和false，运算符`&&和||`都会引起短路行为，而且&&的优先级比||更高

### 字符串
1. 文本字符串被解读为按UTF-8编码的Unicode码点（文字符号）序列，内置的len函数返回字符串的字节数（并非文字符号的数目）。字符串的第i个字节不一定就是第i个字符，因为非ascii字符的UTF-8码点需要两个字节或多个字节
2. 字符串比较运算按字节进行，结果服从本身的字典排序。尽管可以将新值赋予字符串变量，但是字符串值无法改变:字符串值本身所包含的字节序列永不可变，因此无法通过下标的方式给字符串的某个字节赋值
3. 