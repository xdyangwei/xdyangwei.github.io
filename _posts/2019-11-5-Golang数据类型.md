### 整数与浮点数
1. Go的数据类型分四大类：基础类型、聚合类型、引用类型和接口类型。基础类型包括数字、字符串和布尔型
2. `rune`类型是int32类型的同义词，常用于指明一个值是Unicode码点，这两个名称可互换使用。`byte`类型同样是int8类型的同义词，强调一个值是原始数据而非量值
3. 有符号整数以补码表示，保留最高位为符号位，n位数字的取值范围为-2<sup>n-1</sup>~2<sup>n-1</sup>-1,无符号整数由全部位构成其非负值，范围是0~2<sup>n</sup>-1
4. Go中取模整数运算符%仅能用于整数，取模余数的正负号总是与被除数一致，除法运算的行为取决于操作数是否都为整型
5. 运算符`^`作为二元运算符为异或，作为一元运算符则为按位取反，运算符`&^`是按位清除：表达式`z=x&^y`中，若y的某位为1，则z的对应位为0，否则等于x的相应位
6. 左移以0填补右边空位，无符号整数右移同样以0填补左边空位，有符号整数右移是按符号位的值填补空位
7. 如果使用fmt包输出数字，我们可以使用谓词%d、%o和%x指定进位制基数和输出格式。通常Printf的格式化字符串含有多个%谓词，这要求提供相同数量的操作数，而%后的谓词`[1]`告知Printf重复使用第一个操作数，而%o、%x或%x之前的副词`#`告知Printf输出相应的前缀0、0x或0X
8. 用%c输出文字符号，如果希望输出带有单引号则用%q
9. 浮点数能方便地通过谓词%g输出，该谓词会自动保持足够的精度，并选择最合适的表示方式，但是对于数据表。%e（有指数）和%f（无指数）的形式可能更合适，这三个谓词都能掌控输出宽度和数值精度
10. 所有数字包括NaN自身与NaN的比较总不成立（除了!=，它总是与==相反）
11. Go具备两种大小的复数complex64与complex128，二者分别由float32与float64构成，内置的complex函数根据给定的实部和虚部创建复数，而内置的real函数和imag函数则分别提取复数的实部或虚部。在浮点数或十进制整数后面紧接着写字母i，它就变成了一个虚数
12. bool型的值或布尔值（boolean）只有两种可能：true和false，运算符`&&和||`都会引起短路行为，而且&&的优先级比||更高

### 字符串
1. 文本字符串被解读为按UTF-8编码的Unicode码点（文字符号）序列，内置的len函数返回字符串的字节数（并非文字符号的数目）。字符串的第i个字节不一定就是第i个字符，因为非ascii字符的UTF-8码点需要两个字节或多个字节
2. 字符串比较运算按字节进行，结果服从本身的字典排序。尽管可以将新值赋予字符串变量，但是字符串值无法改变:字符串值本身所包含的字节序列永不可变，因此无法通过下标的方式给字符串的某个字节赋值
3. 原生的字符串字面量的书写形式是\`...\`，使用反括号而不是双引号，其中转义序列不起作用：实质内容与字面写法严格一致，包括反斜杠和换行符
4. Go语言中，字符串字面量的转义让我们得以用码点的值来指明Unicode字符，有两种形式：\\uhhhh表明16位码点值，\\Uhhhhhhhh表示32位码点值
5. 由于UTF-8的优良特性，许多字符串操作都无须解码，当[]rune转换作用于UTF-8编码的字符串时，返回该字符串的Unicode码点序列。如果把文字符号类型的slice转换成一个字符串，它会输出各个文字符号的UTF-8编码拼接结果，若将一个整数值转换成字符串，其值按文字符号类型解读，并且产生该文字符号的UTF-8码
6. 字符串和字节slice可以相互转换。为了避免转换和不必要的内存分配，bytes包和strings包都预备了许多对应的应用函数，它们两两相对应
7. 要将整数转换成字符串，一种选择是使用fmt.Sprintf，另一种做法是用函数strconv.Itoa,而strconv中的FormatInt和FormatUInt可以按不同的进位制格式化数字，而当要包含除数字以外的额外信息时Sprintf中谓词%b、%d、%x往往比Format函数更为方便
8. strconv包内的Atoi函数或ParseInt函数用于解释表示整数的字符串，ParseUInt用于无符号整数

### 常量
1. 常量是一种表达式，其可以保证在编译阶段就计算出表达式的值，并不需要等到运行时，所有变量本质上都属于基本类型
2. 对于常量操作数，所有数学运算、逻辑运算和比较运算的结果依然是常量，常量的类型转换结果和某些内置函数的返回值，比如len、cap、real等，同样是常量
3. 常量声明可以同时指定类型和值，如果没有显式指定类型，则类型根据右边的表达式推断。若同时声明一组常量，除了第一项外，其他项在等号右侧的表达式可以省略，这意味着会复用前面一项的表达式及其类型
4. 常量的声明可以使用常量生成器iota，它创建一系列相关值，而不是逐个值显式写出，常量声明中，iota从0开始取值，逐项加1
5. 许多常量并不从属某一具体类型，编译器将这些从属类型待定的常量表示成某些值，这些值比基本类型的数字精度更高，且算术精度高于原生的机器精度
6. 从属类型待定的常量共有6种，分别为无类型布尔、无类型整数、无类型文字符号、无类型浮点数、无类型复数、无类型字符串。
7. 借助推迟从属类型，无类型常量不仅能暂时维持更高的精度，与类型已确定的常量相比，它们还能写进更多表达式而无需转换类型
8. 只有常量才可以是无类型的，若将无类型常量声明为变量或在类型明确的变量赋值的右方出现无类型常量，则常量会被隐式转换为该变量的类型
9. 无论隐式显式，常量从一种类型转换成另一种，都要求目标类型能够表示原值，实数和复数允许舍入取值
10. 变量声明（包括短变量声明）中，假如没有显式指定类型，无类型常量会隐式转换成该变量的默认类型。要将变量转换成不同的类型，我们必须将无类型常量显式转换为期望的类型，或在声明变量时指明想要的类型
11. Go语言中，只有大小不明确的int类型，不存在大小不确定的float类型和complex类型，因为如果浮点数的大小不明，就很难写出正确的数值算法

### 数组和slice
1. 数组是拥有固定长度且拥有零个或多个相同数据类型元素的序列。默认情况下一个新数组中的元素初始值为元素类型的零值，也可使用数组字面量根据一组值来初始化一个数组
2. 在数组字面量中，如果省略号“...”出现在数组长度的位置，那么数组的长度由初始化数组的元素个数决定
3. 数组的长度是数组类型的一部分，因此元素类型相同但是大小不同的数组不是同一类型，数组的长度必须是常量表达式
4. 数组初始化中没有指定值的索引位置的元素默认被赋予数组元素类型的零值。如果数组元素类型是可比较的，数组也是可比较的，比较结果是两边元素的值是否完全相同，大小不同的数组不能进行比较
5. Go把数组和其他类型都看成值传递，如需进行修改则需要显式传递数组和其他类型的指针
6. slice表示一个拥有相同类型元素的可变长度的序列，通常写成[]T，元素类型是T，看上去像没有长度的数组类型
7. slice用来访问数组的部分或全部元素，这个数组称为slice的底层数组
8. slice有三个属性：指针、长度和容量，指针指向数组中第一个可以从slice中访问的元素，不一定是数组的第一个元素，长度是指slice中元素的数量，不能超过容量，容量的大小通常是从slice的起始元素到底层数组的最后一个元素间元素的个数，内置的len和cap函数可以返回slice的长度和容量
9. 如果slice的引用超过了被引用对象的容量，即cap(s)，那么会程序报错，如果slice的长度超出了被引用对象slice的长度len(s)，那么最终slice会比原slice长
10. slice包含了指向数组元素的指针，所以将一个slice传递给函数的时候，可以在函数内部修改底层数组的元素
11. 和数组不同，slice无法做比较，检查一个slice是否为空，可以通过len(s)来检查，因为slice!=nil的情况下也有可能为空
12. 可以使用make函数创建一个具有指定元素类型、长度和容量的slice，容量参数省略的情况下长度和容量相等
    ```
    make([]T,len)
    make([]T,len,cap)//和make([]T,cap)[:len]功能相同
    ```
13. 内置函数append用来将元素追加到slice的后面
14. 对于任何函数，只要有可能改变slice的长度或容量，抑或是使得slice指向不同的底层数组，都需要更新slice变量

