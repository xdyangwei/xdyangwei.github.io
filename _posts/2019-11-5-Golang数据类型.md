### 整数与浮点数
1. Go的数据类型分四大类：基础类型、聚合类型、引用类型和接口类型。基础类型包括数字、字符串和布尔型
2. `rune`类型是int32类型的同义词，常用于指明一个值是Unicode码点，这两个名称可互换使用。`byte`类型同样是int8类型的同义词，强调一个值是原始数据而非量值
3. 有符号整数以补码表示，保留最高位为符号位，n位数字的取值范围为-2<sup>n-1</sup>~2<sup>n-1</sup>-1,无符号整数由全部位构成其非负值，范围是0~2<sup>n</sup>-1
4. Go中取模整数运算符%仅能用于整数，取模余数的正负号总是与被除数一致，除法运算的行为取决于操作数是否都为整型
5. 运算符`^`作为二元运算符为异或，作为一元运算符则为按位取反，运算符`&^`是按位清除：表达式`z=x&^y`中，若y的某位为1，则z的对应位为0，否则等于x的相应位
6. 左移以0填补右边空位，无符号整数右移同样以0填补左边空位，有符号整数右移是按符号位的值填补空位
7. 如果使用fmt包输出数字，我们可以使用谓词%d、%o和%x指定进位制基数和输出格式。通常Printf的格式化字符串含有多个%谓词，这要求提供相同数量的操作数，而%后的谓词`[1]`告知Printf重复使用第一个操作数，而%o、%x或%x之前的副词`#`告知Printf输出相应的前缀0、0x或0X
8. 用%c输出文字符号，如果希望输出带有单引号则用%q
9. 浮点数能方便地通过谓词%g输出，该谓词会自动保持足够的精度，并选择最合适的表示方式，但是对于数据表。%e（有指数）和%f（无指数）的形式可能更合适，这三个谓词都能掌控输出宽度和数值精度
10. 所有数字包括NaN自身与NaN的比较总不成立（除了!=，它总是与==相反）
11. Go具备两种大小的复数complex64与complex128，二者分别由float32与float64构成，内置的complex函数根据给定的实部和虚部创建复数，而内置的real函数和imag函数则分别提取复数的实部或虚部。在浮点数或十进制整数后面紧接着写字母i，它就变成了一个虚数
12. bool型的值或布尔值（boolean）只有两种可能：true和false，运算符`&&和||`都会引起短路行为，而且&&的优先级比||更高

### 字符串
1. 文本字符串被解读为按UTF-8编码的Unicode码点（文字符号）序列，内置的len函数返回字符串的字节数（并非文字符号的数目）。字符串的第i个字节不一定就是第i个字符，因为非ascii字符的UTF-8码点需要两个字节或多个字节
2. 字符串比较运算按字节进行，结果服从本身的字典排序。尽管可以将新值赋予字符串变量，但是字符串值无法改变:字符串值本身所包含的字节序列永不可变，因此无法通过下标的方式给字符串的某个字节赋值
3. 原生的字符串字面量的书写形式是\`...\`，使用反括号而不是双引号，其中转义序列不起作用：实质内容与字面写法严格一致，包括反斜杠和换行符
4. Go语言中，字符串字面量的转义让我们得以用码点的值来指明Unicode字符，有两种形式：\\uhhhh表明16位码点值，\\Uhhhhhhhh表示32位码点值
5. 由于UTF-8的优良特性，许多字符串操作都无须解码，当[]rune转换作用于UTF-8编码的字符串时，返回该字符串的Unicode码点序列。如果把文字符号类型的slice转换成一个字符串，它会输出各个文字符号的UTF-8编码拼接结果，若将一个整数值转换成字符串，其值按文字符号类型解读，并且产生该文字符号的UTF-8码
6. 字符串和字节slice可以相互转换。为了避免转换和不必要的内存分配，bytes包和strings包都预备了许多对应的应用函数，它们两两相对应
7. 要将整数转换成字符串，一种选择是使用fmt.Sprintf，另一种做法是用函数strconv.Itoa,而strconv中的FormatInt和FormatUInt可以按不同的进位制格式化数字，而当要包含除数字以外的额外信息时Sprintf中谓词%b、%d、%x往往比Format函数更为方便
8. strconv包内的Atoi函数或ParseInt函数用于解释表示整数的字符串，ParseUInt用于无符号整数

### 常量
1. 常量