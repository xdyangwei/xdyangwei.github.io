### 管理线程
1. 当指定的入口函数返回时，该线程就会退出，std::thread可以与任何可调用(callable)类型一起工作，包括函数、lambda表达式、函数指针、带有函数调用操作的类的实例等
2. 我们所提供的函数对象被**复制**到属于新创建的执行线程的存储器中，并从那里调用
3. 我们需要在std::thread对象被销毁之前决定线程是结合还是分离，线程本身可能在结合或分离它之前早就已经结束了，否则程序就会被终止（std::thread的析构函数调用std::terminate()）
4. 如果我们不等待线程完成，那么我们需要确保通过该线程访问的数据是有效的，直到该线程完成为止，特别是当线程函数持有局部变量的指针或引用，且函数退出时候线程尚未完成时。我们可以通过结合（join）线程确保在函数退出前该线程执行完毕
5. 如果一个线程成为分离的，获取一个引用它的std::thread对象也是不可能的，所以它也不再能够被结合，被分离的线程通常被称为**守护线程**，无需任何显式的用户界面，而运行在后台
6. std::thread构造函数中的参数会以默认的方式被**复制**到内部存储空间，即使函数中的相应参数为引用，此时如果我们需要引用可以用std::ref来包装确实需要被引用的参数，这样就能正确传入参数的引用
7. 当我们传递一个成员函数的指针作为参数时，前提是提供一个合适的对象指针作为第一个参数，构造函数的第三个参数会成为成员函数的第一个参数。
8. std::thread对象是可移动的，但是不可复制，这确保了在任意时刻只有一个对象与特定的执行线程相关联
9. 当一个std::thread对象已经有了一个相关联的线程的情况下，我们不能仅仅通过向管理线程的std::thread对象赋值一个新的值来“舍弃”一个线程
10. `std::thread::hardware_currency()`返回一个对于给定程序执行时能够真正并发运行的线程数量的指示，如果该信息不可用可能会返回0.当我们运行比硬件所能支持的更多的线程时，上下文的切换将意味着更多的线程会降低性能
11. 线程标识符是`std::thread::id`类型的，我们可以通过指定的std::thread对象调用`get_id()`成员函数来获得，也可以在当前线程通过调用`std::this_thread::get_id()`来获得当前线程的线程标识符。如果两个线程标识符相等，则它们代表着同一个线程或两者都具有“没有线程”的值