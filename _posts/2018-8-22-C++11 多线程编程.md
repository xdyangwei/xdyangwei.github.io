## C++11 多线程编程

1. 多线程是实现并发（并行）的一种手段。**并行**是指两个或多个独立的操作**同时进行**。注意这里是*同时进行*，区别于**并发**，在一个时间段内执行多个操作。在单核时代，多个线程是**并发**的，在一个时间段内轮流执行；在多核时代，多个线程可以实现真正的**并行**，在多核上真正独立的并行执行。例如现在常见的**4核4线程**可以并行4个线程；**4核8线程**则使用了超线程技术，把一个物理核模拟为2个逻辑核心，可以并行8个线程。

2. 通常，要实现并发有两种方法：多进程和多线程。

3. ### 多进程并发

   使用多进程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以互相通信，共同完成任务。由于操作系统对进程提供了大量的保护机制，以避免一个进程修改了另一个进程的数据，使用多进程比多线程更容易写出安全的代码。但这也造就了多进程并发的两个缺点：

   在进程间的通信，无论是使用信号、套接字，还是文件、管道等方式，其使用要么比较复杂，要么就是速度较慢或者两者兼而有之。

   运行多个进程的开销很大，操作系统要分配很多的资源来对这些进程进行管理。

   由于多个进程并发完成同一个任务时，不可避免的是：操作同一个数据和进程间的相互通信，上述的两个缺点也就决定了多进程的并发不是一个好的选择。

4. ### 多线程并发
   多线程并发指的是在同一个进程中执行多个线程。线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，**同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递**。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力避免**死锁（deadlock）**。

5. C++11的标准库中提供了多线程库，使用时需要`#include <thread>`头文件，该头文件主要包含了对线程的管理类`std::thread`以及其他管理线程相关的类。

6. **共享数据的管理**以及**线程间的通信**，是多线程编程的两大核心。

7. C++ 11的线程库启动一个线程是非常简单的，只需要创建一个`std::thread`对象，就会启动一个线程，并使用该`std::thread`对象来管理该线程。这里创建`std::thread`传入的函数，实际上其构造函数需要的是可调用（callable）类型，只要是有函数调用类型的实例都是可以的。所有除了传递函数外，还可以使用：
  Lambda表达式、重载了()运算符的类的实例。

8. 把函数对象传入`std::thread`的构造函数时，要注意一个C++的语法解析错误（C++'s most vexing parse）。向`std::thread`的构造函数中传入的是一个临时变量，而不是命名变量就会出现语法解析错误。
  `std::thread t(Task())`;这里相当于声明了一个函数t，其返回类型为`thread`，而不是启动了一个新的线程。可以使用新的初始化语法避免这种情况`std::thread t{Task()}`;

9. 当线程启动后，**一定要在和线程相关联的thread销毁前，确定以何种方式等待线程执行结束**。C++11有两种方式来等待线程结束:
   * detach方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束。
   * join方式，等待启动的线程完成，才会继续往下执行。

10. 无论在何种情形，一定要在`thread`销毁前，调用`t.join`或者`t.detach`，来决定线程以何种方式运行。当使用join方式时，会阻塞当前代码，等待线程完成退出后，才会继续向下执行；而使用detach方式则不会对当前代码造成影响，当前代码继续向下执行，创建的新线程同时并发执行，这时候需要特别注意：**创建的新线程对当前作用域的变量的使用**，创建新线程的作用域结束后，有可能线程仍然在执行，这时局部变量随着作用域的完成都已销毁，如果线程继续使用局部变量的**引用或者指针**，会出现意想不到的错误，并且这种错误很难排查。

11. 在以detach的方式执行线程时，要将线程访问的局部数据复制到线程的空间（使用值传递），一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域结束前执行结束。当然，使用join方式的话就不会出现这种问题，它会在作用域结束前完成退出。

12. 当决定以detach方式让线程在后台运行时，可以在创建`thread`的实例后立即调用`detach`，这样线程就会后`thread`的实例分离，即使出现了异常`thread`的实例被销毁，仍然能保证线程在后台运行。但线程以join方式运行时，需要在主线程的合适位置调用`join`方法，如果调用`join`前出现了异常，`thread`被销毁，线程就会被异常所终结。为了避免异常将线程终结，或者由于某些原因，例如线程访问了局部变量，就要保证线程一定要在函数退出前完成，就要保证要在函数退出前调用`join`

13. 解决这个问题的一种比较好的方法是资源获取即初始化（RAII,Resource Acquisition Is Initialization)，该方法提供一个类，在析构函数中调用`join`。

14. 向线程调用的函数传递参数也是很简单的，只需要在构造`thread`的实例时，依次传入即可。如果在线程中使用引用来更新对象时，就需要注意了。默认的是将对象拷贝到线程空间，其引用的是拷贝的线程空间的对象，而不是初始希望改变的对象。、

15. 线程启动的函数形参引用的实际上是局部变量`node`的一个拷贝，而不是`node`本身。在将对象传入线程的时候，调用`std::ref`，将`node`的引用传入线程，而不是一个拷贝。`thread t(func,std::ref(node));`也可以使用类的成员函数作为线程函数，第二个参数为类对象的引用，第三个参数为成员函数的第一个参数，以此类推。

16. `thread`是可移动的(movable)的，但不可复制(copyable)。可以通过`move`来改变线程的所有权，灵活的决定线程在什么时候join或者detach。``` thread t1(f1);thread t3(move(t1));```将线程从t1转移给t3,这时候t1就不再拥有线程的所有权，调用`t1.join`或`t1.detach`会出现异常，要使用t3来管理线程。这也就意味着`thread`可以作为函数的返回类型，或者作为参数传递给函数，能够更为方便的管理线程。

17. 线程的标识类型为`std::thread::id`，有两种方式获得到线程的id。

    - 通过`thread`的实例调用`get_id()`直接获取
    - 在当前线程上调用`this_thread::get_id()`获取
