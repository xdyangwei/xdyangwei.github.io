### 优先选用基于任务而非基于线程的程序设计
1. 创建std::thread然后在其上运行函数对象从而以异步方式运行函数对象的方式称为基于线程的途径，而将函数对象传递给std::async的方式称为基于任务的途径，此时函数对象被看做任务。
2. 基于任务的方法通常要比基于线程实现的对应版本要好，因为基于线程的版本无法直截了当的获取函数的返回值，但是使用std::async返回的期值提供了get函数。在异常处理方面，如果调用的函数发生异常，get函数能访问到该异常，而如果使用基于线程的途径，函数抛出异常，程序就会中断(调用std::terminate)。
3.  线程在C++中的三种意义：  
（1）硬件线程是实际执行运算的线程，计算机会为每个cpu内核提供一个或多个硬件线程。  
（2）软件线程（系统线程）是操作系统用以实施跨进程管理，以及进行硬件线程调度的线程。通常能够创建的软件线程会比硬件线程要多，因为当软件线程阻塞时，运行另外的非阻塞线程能够提升系统吞吐量。  
（3）std::thread是C++进程里的对象，用作底层软件线程的句柄，有些std::thread对象表示为“null”句柄，对应“无软件线程”。
4. 软件线程是一种有限的资源，如果我们试图创建的线程数量多于系统能够提供的数量时，就会抛出std::system_error异常，即使待运行函数不能抛出异常（带有noexcept饰词）也会抛出异常。
5. 即使没有用尽线程，系统可能还是会出现超订问题：就绪状态的软件线程超过了硬件线程的数量，这种情况下线程调度器会为软件线程在硬件线程上分配cpu时间片。当一个线程的时间片用完时，切换到另一个线程时会执行语境切换，语境切换会增加系统的总体线程管理开销。
6. 避免线程用尽以及超订问题是困难的，std::async就能帮我们解决这一问题。调用std::async时，系统不保证会创建一个新的软件线程，相反它允许调度器把指定函数运行在请求这个函数运行结果的线程中（对std::async返回期值调用get或wait的线程），如果系统发生了超订或线程耗尽，合理的调度器就可以利用这个自由度。
7. 相比较基于线程编程，基于任务的设计能够分担我们手工管理线程的艰辛，并且它能够让我们很简单地可以检查异步执行函数的结果（返回值或异常）。
8. 虽然基于任务的设计有诸多好处，但是在以下场景下还是直接使用线程会更加合适：  
（1）需要访问底层线程实现的API：std::thread通常会提供native_handle成员函数来访问底层线程实现的API，但是std::async的返回值类型std::future并没有该功能  
（2）需要且有能力为自己的应用优化线程用法。
（3）需要实现超越C++并发API的线程技术，比如实现线程池

###