### 优先选用基于任务而非基于线程的程序设计
1. 创建std::thread然后在其上运行函数对象从而以异步方式运行函数对象的方式称为基于线程的途径，而将函数对象传递给std::async的方式称为基于任务的途径，此时函数对象被看做任务。
2. 基于任务的方法通常要比基于线程实现的对应版本要好，因为基于线程的版本无法直截了当的获取函数的返回值，但是使用std::async返回的期值提供了get函数。在异常处理方面，如果调用的函数发生异常，get函数能访问到该异常，而如果使用基于线程的途径，函数抛出异常，程序就会中断(调用std::terminate)。
3.  线程在C++中的三种意义：  
（1）硬件线程是实际执行运算的线程，计算机会为每个cpu内核提供一个或多个硬件线程。  
（2）软件线程（系统线程）是操作系统用以实施跨进程管理，以及进行硬件线程调度的线程。通常能够创建的软件线程会比硬件线程要多，因为当软件线程阻塞时，运行另外的非阻塞线程能够提升系统吞吐量。  
（3）std::thread是C++进程里的对象，用作底层软件线程的句柄，有些std::thread对象表示为“null”句柄，对应“无软件线程”。
4. 软件线程是一种有限的资源，如果我们试图创建的线程数量多于系统能够提供的数量时，就会抛出std::system_error异常，即使待运行函数不能抛出异常（带有noexcept饰词）也会抛出异常。
5. 即使没有用尽线程，系统可能还是会出现超订问题：就绪状态的软件线程超过了硬件线程的数量，这种情况下线程调度器会为软件线程在硬件线程上分配cpu时间片。当一个线程的时间片用完时，切换到另一个线程时会执行语境切换，语境切换会增加系统的总体线程管理开销。
6. 避免线程用尽以及超订问题是困难的，std::async就能帮我们解决这一问题。调用std::async时，系统不保证会创建一个新的软件线程，相反它允许调度器把指定函数运行在请求这个函数运行结果的线程中（对std::async返回期值调用get或wait的线程），如果系统发生了超订或线程耗尽，合理的调度器就可以利用这个自由度。
7. 相比较基于线程编程，基于任务的设计能够分担我们手工管理线程的艰辛，并且它能够让我们很简单地可以检查异步执行函数的结果（返回值或异常）。
8. 虽然基于任务的设计有诸多好处，但是在以下场景下还是直接使用线程会更加合适：  
（1）需要访问底层线程实现的API：std::thread通常会提供native_handle成员函数来访问底层线程实现的API，但是std::async的返回值类型std::future并没有该功能  
（2）需要且有能力为自己的应用优化线程用法。
（3）需要实现超越C++并发API的线程技术，比如实现线程池

### 如果异步是必要的，则指定std::launch::async

1. 仅仅调用std::async，函数不一定会以异步方式运行，因为此时采用的是默认启动策略使用std::async。默认启动策略就允许函数以异步或同步的方式运行皆可。
2. 除去默认启动策略外，std::launch::async启动策略意味着函数f必须以异步方式运行，也就是在另一线程上运行。  
std::launch::deferred启动策略意味函数只会在std::async所返回的期望的get或wait得到调用时才运行，也就是说，函数的执行会推迟至其中一个调用发生的时刻。当调用get或wait时，函数会同步运行，调用方会阻塞至函数运行结束为止，如果get或wait都没有得到调用函数是不会运行的。  
默认启动策略是对上述两者策略进行或运算的结果。
3. 使用默认启动策略可能会发生一些我们不可知的结果：  
（1）无法预知函数是否会和原线程并发运行，因为f可能会被调度为推迟运行  
（2）无法预知函数是否运行在与调用期值的get或wait函数的线程不同的某线程之上  
（3）连函数是否会运行这件事情都无法预知，因为无法保证期值的get或wait都会得到调用
4. 默认启动策略在调度上的弹性会在使用thread_local变量时导致不明不白的混淆，因为这意味着如果函数读或写此线程级存储时，无法预知会取到的是哪个线程的局部存储。它也会影响那些基于wait的循环中以超时为条件者。这一类缺陷在开发或单元测试中很容易被忽略，因为只有在运行负载很重时才会现身
5. 修正这一困难并不难：校验std::async返回的期值，确定任务是否被推迟，然后如果确实被推迟了，则避免进入基于超时的循环，但是没有直接的办法来询问期值任务是否被推迟了，作为替代，我们需要先调用一个基于超时的函数，比如wait_for，只需要在超时为0时查看返回值是否是std::future_status::deferred就行。
    ```
    auto fut=std::async(f);
    if(fut.wait_for(0s)==std::future_status::deferred){
        ...
    }else{
        ...
    }
    ```
6. 以默认启动策略对任务使用std::async能够正常工作需要满足以下所有条件：  
（1）任务不需要与调用get或wait的线程并发执行  
（2）读/写哪个线程的thread_local变量并无影响  
（3）要么可以给出保证在std::async返回的期值之上调用get或wait，要么可以接受任务可能永不执行  
（4）使用wait_for或wait_until的代码会将任务被推迟的可能性纳入考量  
只要其中一个条件不满足，你就很有可能想要确保任务以异步方式执行，此时需要在调用时把std::launch::async作为第一个实参传递：  
    ```
    auto fut=std::async(std::launch::async,f);
    ```

### 使std::thread类型对象在所有路径皆不可联结

1. 