### 优先选用基于任务而非基于线程的程序设计
1. 创建std::thread然后在其上运行函数对象从而以异步方式运行函数对象的方式称为基于线程的途径，而将函数对象传递给std::async的方式称为基于任务的途径，此时函数对象被看做任务。
2. 基于任务的方法通常要比基于线程实现的对应版本要好，因为基于线程的版本无法直截了当的获取函数的返回值，但是使用std::async返回的期值提供了get函数。在异常处理方面，如果调用的函数发生异常，get函数能访问到该异常，而如果使用基于线程的途径，函数抛出异常，程序就会中断(调用std::terminate)。
3.  线程在C++中的三种意义：  
（1）硬件线程是实际执行运算的线程，计算机会为每个cpu内核提供一个或多个硬件线程。  
（2）软件线程（系统线程）是操作系统用以实施跨进程管理，以及进行硬件线程调度的线程。通常能够创建的软件线程会比硬件线程要多，因为当软件线程阻塞时，运行另外的非阻塞线程能够提升系统吞吐量。  
（3）std::thread是C++进程里的对象，用作底层软件线程的句柄，有些std::thread对象表示为“null”句柄，对应“无软件线程”。
4. 软件线程是一种有限的资源，如果我们试图创建的线程数量多于系统能够提供的数量时，就会抛出std::system_error异常，即使待运行函数不能抛出异常（带有noexcept饰词）也会抛出异常。
5. 即使没有用尽线程，系统可能还是会出现超订问题：就绪状态的软件线程超过了硬件线程的数量，这种情况下线程调度器会为软件线程在硬件线程上分配cpu时间片。当一个线程的时间片用完时，切换到另一个线程时会执行语境切换，语境切换会增加系统的总体线程管理开销。
6. 避免线程用尽以及超订问题是困难的，std::async就能帮我们解决这一问题。调用std::async时，系统不保证会创建一个新的软件线程，相反它允许调度器把指定函数运行在请求这个函数运行结果的线程中（对std::async返回期值调用get或wait的线程），如果系统发生了超订或线程耗尽，合理的调度器就可以利用这个自由度。
7. 相比较基于线程编程，基于任务的设计能够分担我们手工管理线程的艰辛，并且它能够让我们很简单地可以检查异步执行函数的结果（返回值或异常）。
8. 虽然基于任务的设计有诸多好处，但是在以下场景下还是直接使用线程会更加合适：  
（1）需要访问底层线程实现的API：std::thread通常会提供native_handle成员函数来访问底层线程实现的API，但是std::async的返回值类型std::future并没有该功能  
（2）需要且有能力为自己的应用优化线程用法。
（3）需要实现超越C++并发API的线程技术，比如实现线程池

### 如果异步是必要的，则指定std::launch::async

1. 仅仅调用std::async，函数不一定会以异步方式运行，因为此时采用的是默认启动策略使用std::async。默认启动策略就允许函数以异步或同步的方式运行皆可。
2. 除去默认启动策略外，std::launch::async启动策略意味着函数f必须以异步方式运行，也就是在另一线程上运行。  
std::launch::deferred启动策略意味函数只会在std::async所返回的期望的get或wait得到调用时才运行，也就是说，函数的执行会推迟至其中一个调用发生的时刻。当调用get或wait时，函数会同步运行，调用方会阻塞至函数运行结束为止，如果get或wait都没有得到调用函数是不会运行的。  
默认启动策略是对上述两者策略进行或运算的结果。
3. 使用默认启动策略可能会发生一些我们不可知的结果：  
（1）无法预知函数是否会和原线程并发运行，因为f可能会被调度为推迟运行  
（2）无法预知函数是否运行在与调用期值的get或wait函数的线程不同的某线程之上  
（3）连函数是否会运行这件事情都无法预知，因为无法保证期值的get或wait都会得到调用
4. 默认启动策略在调度上的弹性会在使用thread_local变量时导致不明不白的混淆，因为这意味着如果函数读或写此线程级存储时，无法预知会取到的是哪个线程的局部存储。它也会影响那些基于wait的循环中以超时为条件者。这一类缺陷在开发或单元测试中很容易被忽略，因为只有在运行负载很重时才会现身
5. 修正这一困难并不难：校验std::async返回的期值，确定任务是否被推迟，然后如果确实被推迟了，则避免进入基于超时的循环，但是没有直接的办法来询问期值任务是否被推迟了，作为替代，我们需要先调用一个基于超时的函数，比如wait_for，只需要在超时为0时查看返回值是否是std::future_status::deferred就行。
    ```
    auto fut=std::async(f);
    if(fut.wait_for(0s)==std::future_status::deferred){
        ...
    }else{
        ...
    }
    ```
6. 以默认启动策略对任务使用std::async能够正常工作需要满足以下所有条件：  
（1）任务不需要与调用get或wait的线程并发执行  
（2）读/写哪个线程的thread_local变量并无影响  
（3）要么可以给出保证在std::async返回的期值之上调用get或wait，要么可以接受任务可能永不执行  
（4）使用wait_for或wait_until的代码会将任务被推迟的可能性纳入考量  
只要其中一个条件不满足，你就很有可能想要确保任务以异步方式执行，此时需要在调用时把std::launch::async作为第一个实参传递：  
    ```
    auto fut=std::async(std::launch::async,f);
    ```

### 使std::thread类型对象在所有路径皆不可联结

1. 每个std::thread对象都处于两种状态之一：可联结和不可联结。std::thread对象对应的底层线程若处于阻塞或等待调度状态，则它可联结，若已运行至结束则亦可认为其可联结。而不可联结的thread对象就不处于以上可联结的状态。
2. 不可联结的std::thread类型对象包括：  
（1）默认构造的std::thread，因为此类thread没有可以执行的函数  
（2）已移动的std::thread，移动后一个thread所对应的底层执行线程被对应到另外一个std::thread  
（3）已联结的std::thread，联结后thread对象不再对应至已结束运行的底层执行线程  
（4）已分离的std::thread，分离操作会将thread对象和它对应的底层执行线程之间的连接断开
3. 如果可联结的线程对象的析构函数被调用，则程序的执行就终止了。如果不这样设计，另外两种的设计会更加糟糕：  
（1）隐式join，在这种情况下thread对象的析构函数会等待底层异步执行线程完成，听上去合理但是可能导致难以追踪的性能异常，因为很可能不需要一直等待线程执行完成  
（2）隐式detach，此时thread对象的析构函数会分离thread对象与底层执行线程之间的连接，该底层线程会继续执行，但是当thread对象所在的线程执行完毕后而thread对象又使用了其中局部变量的引用，那么很有可能后续的函数会将此时局部变量的值进行修改。  
因此销毁一个可联结的线程实在太过可怕，因此规定可联结的线程的析构函数导致程序终止。
4. 如果我们使用了thread对象，就得确保从它定义的作用域出去的任何路径，使它成为不可联结状态，最常见的方法就是在局部对象的析构函数中执行该操作，这样的对象称为RAII对象。
5. 一般地，在一个对象之上同时调用多个成员函数，只有当这些函数都是const成员函数时才安全。
6. 一个成员变量的初始化有可能会依赖另一个成员变量，又因为std::thread类型对象初始化之后可能会马上用来运行函数，所以我们应该在成员列表的最后声明std::thread对象。

### 对变化多端的线程句柄析构函数行为保持关注

1. 可联结的线程对应着一个底层操作系统线程，使用std::async所产生的未推迟任务的期值和系统线程也有类似关系，因此thread对象和期值对象都可以视作系统线程的句柄。
2. 期值作为调用方从系统线程这个被调方那里获得结果，但是由于被调方在期值调用get之前就有可能执行完毕，因此结果不会存在被调方的std::promise对象中，因为这是个局部变量，被调方执行完毕后就会被析构。但是也不能存在调用方的期值中，因为可能从future类型对象将所有权转移到std::shared_future对象，可能会被复制多次而如果结果类型是不可复制的则不行，因此结果也不能放在调用方中。
3. 结果最终被保存在被调方和调用方外部的一个位置，这个位置称为共享状态，共享状态通常使用堆上的对象表示。该共享状态由指向它的期值和被调方的std::promise共同操纵。共享状态中包含引用计数，使得库里能够知道何时可以析构共享状态。
4. 期值析构函数的行为是与其关联的共享状态决定的，具体就是：  
（1）指向由std::async启动的未推迟任务的共享状态的最后一个期值会保持阻塞，直至该任务结束，本质上对该线程执行了一次隐式jion  
（2）其他所有期值对象的析构函数只仅仅将期值对象析构就结束了
5. 对线程执行隐式join，析构共享状态的期值析构函数行为只有在以下条件全部满足时才会发挥作用：  
（1）期值所指向的共享状态是由于调用了std::async才创建的  
（2）该任务的启动策略是std::launch::async，可能是默认启动策略时系统的选择，也可能是是我们指定的  
（3）该期值是指向该共享状态的最后一个期值
6. 当我们的期值所对应的共享状态是由std::packaged_task产生的，则通常无须采用特别析构策略，因为关于是终止、联结还是分离的决定，会由操纵std::thread的代码作出，而std::packaged_task通常就运行在该线程之上。

### 考虑针对一次性事件通信使用以void为模板类型实参的期值

1. 