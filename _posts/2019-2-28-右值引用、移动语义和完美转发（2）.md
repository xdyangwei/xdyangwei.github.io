### 熟悉依万能引用类型进行重载的替代方案
1. 针对万能引用类别进行重载会导致形形色色的问题，解决这些问题的办法有：  
舍弃重载，但是不能解决完美转发构造函数的问题，并且彻底放弃重载也不行  
传递const T&类型的形参，使用左值常量引用类型来代替传递万能引用类型，缺点在于达不到我们想要的高效率  
传值：传值不会出现让调用者出乎意料的情况
2. 如果又不想放弃重载，又不想放弃万能引用，只要让函数模板中不止包含万能引用这一形参，另外非万能引用形参只要具备充分差的匹配能力，就足以让这个函数模板不满足精确匹配，这个想法就是标签分派手法的基础。
3. 运用“标签”的唯一目的在于强制重载决议时按我们想要的方向进行推进，这些形参在运行期不起任何作用，针对万能引用函数模板内的重载实现函数发起的调用把工作“分派”到正确的重载版本的手法就是创建合适的标签对象，这种设计因而得名：标签分派。
4. 对于完美转发构造函数，由于编译器自己生成复制和移动构造函数的原因，有时也会调用编译器生成的版本，因此如果在完美转发构造函数使用标签分派并不能保证其会不会绕过标签分派系统，因此标签分配就不能满足我们的需要了。
5. std::enable_if可以让我们把含有万能引用部分的函数模板被允许采用的条件砍掉一部分，可以强制编译器表现出来的行为如同特定的模板不存在一般，这样的模板称为禁用的。
    ```
    class Person{
        public:
        template<typename T,typename=typename std::enable_if<condition>::type>
        explicit Person(T&& n);
        ...
    }
    ```
6. std::is_same可以判断两个类型是否相同，但是引用饰词和cv饰词的加入会使比较结果不同，即使他们都是整型，一个是引用，另一个不是引用比较结果就是false。std::decay\<T\>::type和T相同，区别在于它移除了T的引用和cv饰词（即const和volatile饰词），也可以用于把数组和函数类别强制类型转换成指针类型。
7. is_same比较派生类和基类时结果肯定是false，因此此时派生类调用Person基类的构造函数还是会调用万能引用构造函数，为了解决这一问题，std::is_base_of可以判定一个类型是否由另一个类型派生而来。若T2由T1派生而来，`std::is_base_of<T1,T2>::value`是真，而且所有的`std::is_base_of<T,T>::value`都为真，因为所有类型都可以认为是从自身派生而来。所以使用`std::is_base_of`代替`std::is_same`能得到我们想要的结果。
8. 如果要加上其余限制，可以在enable_if里加上其余条件即可，可以使用&&||等关系运算符
9. 万能引用形参通常在性能方面具备优势，但在易用性，比如传递了非法形参等问题时报错信息可能会让人摸不着头脑。

### 理解引用折叠

1. 实参在传递给函数模板时，推导出来的模板形参会将实参是左值还是右值的信息编码到结果类型中，这个编码操作只有在实参被用以初始化的形参时万能引用时才会发生。
2. 如果传递的实参是个左值，T的推导结果就是左值引用类型，如果传递的实参是个右值，T的推导结果就是非引用类型。
3. 声明和定义“引用的引用”是违法的，但是编译器在特殊的语境下会产生引用的引用。当编译器生成引用的引用时就会触发引用折叠机制。引用折叠出现的语境有四种：  
（1）模板实例化  
（2）auto变量的类型生成  
（3）生成和使用typedef和别名声明  
（4）decltype的运用
4. 如果引用的引用出现在上述语境中，该双重引用会折叠成单个引用，规则如下：  
**如果任一引用为左值引用，则结果为左值引用，否则（即两个皆为右值引用），结果为右值引用**
5. 引用折叠是std::forward得以运作的关键。下面为C++14中std::forward可能的实现
    ```
    template<typename T>
    T&& forward(remove_reference_t<T>& param){
        return static_cast<T&&>(param);
    }
    ```
    传递的param是左值就返回左值引用，右值就返回右值引用。

### 假定移动操作不存在、成本高、未使用

1. 如果类型并不提供对移动的显式支持，也不符合编译器生成移动操作的条件，当然也就没有期待其在C++11下相比C++98有任何性能提升了。
2. 并不是所有的移动操作都是廉价的，比如C++11中新引入的容器std::array，它实质上就是带有STL接口的内建数组。std::array类型的对象其内容都是直接存储在对象内的。
3. 作为对比，string类型采用小型字符串优化（small string optimization，SSO）在实施了基于SSO的实现的前提下，对小型字符串实施移动并不比复制更快。小型字符串会存储在std::string对象内的某个缓冲区内，而不去使用堆上分配的存储。
4. 在这样几个场景中C++11的移动语义不会带来什么好处：  
（1）没有移动操作：待移动的对象未能提供移动操作，因此移动操作变成了复制请求  
（2）移动未能更快：待移动的对象虽有移动操作，但并不比其复制操作更快  
（3）移动不可用：移动本可以发生的语境下，要求移动操作不可发生异常，但该操作未加上noexcept声明  
（4）源对象是个左值，除了极少数例外（局部对象用于返回值优化的少部分情况），只有右值可以作为移动操作的源。

### 熟悉完美转发的失败情形

1. 
