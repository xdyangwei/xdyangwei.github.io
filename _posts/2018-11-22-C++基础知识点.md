## C++基础知识点
### C++中static关键字作用
1. 函数体内static变量的作用域为该函数体，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值
2. 在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其他函数访问（在其他模块内调用需要使用using namespace）
3. 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内
4. 在类中的static成员变量属于整个类，不属于类的对象，所以它没有this指针，这就导致了它仅能访问类的静态成员和静态成员函数。同时不能将静态成员函数定义为虚函数。  
静态成员初始化与一般数据成员初始化不同：
（1）初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；   
（2）初始化时不加该成员的访问权限控制符private、public等  
（3）初始化时使用作用域运算符来标明它所属类，所以得出静态成员初始化格式：  
<数据类型><类名>::<静态数据成员名>=<值>  
为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。
5. static关键字还有一个作用就是使得变量默认初始化为0，因为全局变量和静态变量都存储在静态数据区，静态数据区内存中所有字节的默认值都是0x00，比如将字符数组当做字符串使用时就会比较方便，因为尾元素的下一个字节就是'\0'。

### C++和C的区别

1. 面向过程的思路：分析解决问题所需的步骤，用函数把这些步骤依次实现。   
   C语言是面向过程的编程，它最重要的特点是函数，通过main函数来调用各个子函数。程序运行的顺序都是程序员事先决定好的。  
2. 面向对象的思路：把构成问题的事务分解为各个对象，建立对象的目的，不是完成一个步骤，而是描述某个事务在解决整个问题步骤中的行为。  
C++是面向对象的编程，类是它的主要特点，在程序执行过程中，先由主main函数进入，定义一些类，根据需要执行类的成员函数，过程的概念被淡化了（实际上过程还是有的，就是主函数的哪些语句），以类驱动程序运行，类就是对象，所以我们称之为面向对象程序设计。面向对象在分析和解决问题的时候，将涉及到的数据和数据的操作封装在类中，通过类可以创建对象，以事件或消息来驱动对象执行处理。
3. C++对C的“增强”，表现在以下几个方面：
类型检查更为严格。增加了面向对象的机制。增加了泛型编程的机制（Template）。增加了异常处理。增加了运算符重载。增加了标准模板库（STL）。增加了命名空间，避免全局命名冲突。
4. C的大部分代码在C++上都能应用，而C++的代码在C上不能应用。（**记住是大部分，不是所有**）C++是C语言的超集，虽然C++兼容C，但是C++中也有与Ｃ语言中不兼容的地方。
5. C++与C不兼容之处：  
（1）变量声明的位置  
C中变量声明和代码是分开的，必须在函数开始处声明；  
C++中，变量可以在任意处声明，只要保证先声名后使用的原则就可以。
（2）struct结构体  
用struct定义变量`struct mystruct{ int i;float x;}`在c中声明struct变量要这么写：`struct mystruct a;`在C++中前面不用加struct：`mystruct a;`一种兼容的用法是：`typedef struct _mystruct{int i;float x;} mystruct;`然后用mystruct 定义变量。枚举型(enum),联合体类型(union)也是同样。   
在C++中，struct结构体支持成员函数的定义，C中不行。另外要注意的是，C++中成员函数的默认访问说明符为public,这一点和类不同，类的默认访问说明符为private.  
（3）bool类型值  
C++中有bool(或boolean类型);C中可没有这样的bool类型，均为数值类型！需要注意的是真为非零(如：１，５２，-５，-２等)，假的数值为０。  
（4）注释的不同  
C中的注释至有一种 /*......*/;  
C++中的注释包含两种/*......*/和//。  
（5）强制数据类型装换  
Ｃ中的强制转化形式为：(类型)变量；  
C++中还可以使用:类型(变量)的形式以及四种cast。  
（6）函数  
Ｃ语言中函数没有参数默认值，在C++中函数有参数默认值的概念，注意参数默认值与函数重载的区别。  
C语言中函数的定义又两种形式，经典形式和标准形式，C++中只支持标准形式。  
标准形式：`int string(int x,float y){......}`  
经典形式: `int string(x,y)int x;float y;{......}`  
C++的函数必须先声名原型或定义才能使用,因为C++是强数据类型语言,在C语言中,未声名和定义函数之前调用函数是允许的.  
C语言中产生函数符号的规则是根据名称产生，这也就注定了c语言不存在函数重载的概念。而C++生成函数符号则考虑了函数名、参数个数、参数类型。需要注意的是函数的返回值并不能作为函数重载的依据，也就是说int sum和double sum这两个函数是不能构成重载的！  
我们的函数重载也属于多态的一种，这就是所谓的静多态。  
静多态：函数重载，函数模板  
动多态（运行时的多态）：继承中的多态（虚函数）。  
（7）const  
C语言中的const：被修饰后不能做左值，可以不初始化，但是之后没有机会再初始化。不可以当数组的下标，可以通过指针修改。简单来说，它和普通变量的区别只是不能做左值而已。其他地方都是一样的。  
C++中的const：真正的常量。定义的时候必须初始化，可以用作数组的下标。const在C++中的编译规则是替换（和宏很像），所以它被看作是真正的常量。也可以通过指针修改。需要注意的是，C++的指针有可能退化成C语言的指针。  
    ```
    int b=20;
    const int a=b;
    ```  
   这时候的a就只是一个普通的C语言的const常变量了，已经无法当数组的下标了。（引用了一个编译阶段不确定的值）   
（8）运算符&  
&运算符最基本的含义是取地址，C和Ｃ++中都支持这一语法。但在C++中&还可以表示引用。有了引用的概念后函数调用可以作为左值。例如：  
`int &rtux()......rtux()=5;`
以上表达式在C++中完全正确，但在C语言中是非法的。  
引用底层就是指针，使用时会直接解引用，可以配合const对一个立即数进行引用。  
（9）extern说明符  
在C语言的某些版本中，可以在程序中多次使用一个全局变量而无需使用extern说明符。但在C++中除定义全局变量外，在其他模块使用应先用extern生明。 

### new/delete和malloc/free的区别

1. malloc是从堆上开辟空间，而new是从自由存储区开辟；（自由存储区是C++抽象出的概念，不仅可以是堆，还可以是静态存储区）
2. malloc/free是函数，而new/delete是关键词或者说是运算符
3. malloc对开辟的空间大小需要严格指定，而new只需要对象名
4. malloc开辟的空间既可以给单个对象用也可以给数组用，释放的方式都是free；而new开辟对象数组用的是new[size]，释放的方式是delete[]（尽管内置类型可能不会引起问题，但是自定义类型的话，delete[]需要知道有多少个对象，而这个计数就被放在这块空间的头部）
5. 返回值问题，malloc开辟成功返回void*，需要强制类型转换，失败返回NULL，new成功返回对象指针，失败抛出异常，虽然为了最大程度兼容C，C++new也支持失败返回NULL，但一般不被使用
6. 是否调用构造函数和析构函数，new和free不但负责开辟空间，当使用了自定义类型时还会调用对象的构造函数和析构函数，而malloc/free则不会
7. 是否可以相互调用，new的实现可以用malloc，malloc的实现不可以使用new；
8. 是否可以被重载，new operator/delete operator就是new和delete操作符，而operator new/operator delete是函数。我们可以重载自己的operator new/delete，但是不可以重载new/delete/malloc/free;
9. malloc开辟 的内存如果太小，想要换一块大一点的，可以调用relloc实现，但是new没有直观的方法来改变；
10. 当new中的底层实现如果获取不到更多的内存，会触发new_handler机制，留有一个set_new_handler句柄，看看用户是否设置了这个句柄，如果设置了就去执行，句柄的目的是看看能不能尝试着从操作系统释放点内存，找点内存，如果实在不行就抛出bad_alloc异常；而malloc就没有这种尝试了；

### 


