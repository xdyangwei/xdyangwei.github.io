### STL中map和set异同点
1. map和set都是C++的关联容器，其底层实现都是红黑树，map和set所开放的各种接口实质上都是转调红黑树(RB-tree)的操作行为
2. map中的元素是key-value键值对，关键字起到索引的作用，值则表示与关键字相关联的数据，set与之相对就是关键字的简单集合，set中的每个元素都只包含一个关键字。
3. set的迭代器是const的，不允许修改其元素的值，而map允许修改value,不允许修改key。其原因是map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改的值，再调节平衡，如此一来改变了map和set的结构，导致迭代器失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置为const，不允许修改元素的值，而map则是不允许修改key值，允许修改value值。
4. map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符在map中应该慎用，const_map不能用，只希望确定某个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽量使用find。

### STL迭代器删除元素
1. 对于序列容器vector、deque而言，使用erase(iterator)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器
2. 对于关联容器map、set而言，使用erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可
3. 对于list来说，list使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上述两种正确的方法都可以使用。
4. STL由容器、迭代器、仿函数、算法、分配器、配接器几部分组成。  
他们之间的关系：分配器给容器分配存储空间、算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数。

### vector与list的区别
1. vector:  
连续存储的容器，动态数组，在堆上分配空间  
底层实现：数组  
两倍容量增长  
vector插入新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。  
如果没有剩余空间了，则会重新配置原有元素