### 认识bash这个shell
1. 我们必须通过“shell”将我们输入的命令与内核通信，好让内核可以控制硬件来准确无误地工作。
2. 只要能操作应用程序的接口都能够称为shell
3. bash的主要优点：  
（1）命令记忆功能（history）  
（2）命令与文件补全功能(tab按键的好处)  
（3）命令别名设置功能(alias)  
（4）作业控制、前台、后台控制  
（5）程序脚本  
（6）通配符
4. bash的内置命令：type  
type [-tpa] name  
参数：不加任何参数时type会显示name是外部命令还是内置命令  
-t：type会显示是builtin还是file还是alias命令  
-a:会由PATH变量定义的路径中，将所有含name的命令都列出来，包含alias  
-p：如果后面接的name为外部命令时，才会显示完整文件名
5. 当一行命令输入太长想要多行输入时可以输入\，因为\是转义字符将enter字符进行了转义就不会立马执行 

### shell的变量功能
1. 变量就是一组文字或符号等，来替代一些设置或者是设置或者是一串保留的数据
2. 利用`echo`命令能够读出变量所表示的内容，只需要在变量名称前面加上`$`，或是以`${变量}`的方式来显式就可以。
3. 在bash当中，当一个变量名称尚未被设置时，默认的内容是“空”的，另外变量在设置时，还是需要符合某些规则：  
（1）变量与变量内容以一个等号“=”来连接  
（2）等号两边不能直接接空格符  
（3）变量名称只能是英文字母与数字，但是开头字符不能是数字  
（4）变量内容若有空格符可使用双引号"或单引号'将变量内容结合起来，但是  
双引号内的特殊字符如$，可以保有原本的特性  
单引号内的特殊字符则仅为一般字符（纯文本）  
（5）可以使用转义字符"\\"将特殊字符（如enter、空格符等）变成一般字符  
（6）如果在命令中还需要通过其他的命令提供的信息，可以使用反单引号"\`命令\`"或"$(命令)"   
（7）若该变量为了增加变量内容，则可用“$变量名称”或${变量}累加内容  
（8）若该变量需要在其他子进程执行，则需要在以export来使变量变成环境变量  
（9）通常大写字母为系统默认变量，自行设置变量可以使用小写字符，方便判断(纯粹依照用户兴趣与嗜好)  
（10）取消变量的方法为使用"unset变量名称"
4. 用`env`查看环境变量与常见环境变量说明,用set可以查看所有变量（含环境变量与自定义变量），其中bash变量中有些变量值得注意：  
（1）PS1(提示符的设置)  
（2）$(关于本shell的PID)，要是想知道shell的PID，用`echo $$`即可  
（3）?(关于上个执行命令的回传码)，如果某命令被成功执行，则会回传一个0值，如果没被成功执行则会回传“错误代码”，要是想知道上个命令的回传码只需`echo $?`即可。
5. 环境变量与自定义变量的差异在于该变量是否会被子进程所继续引用，环境变量可以而自定义变量则不行，子进程仅仅继承父进程的环境变量不继承自定义变量，因此我们可以使用export命令将自定义变量变成环境变量
6. 当启动一个shell，操作系统会分配一块记忆块给shell使用，此内存内的变量可以让子进程使用，当父进程使用利用export功能时可以让自定义变量的内容写到上述记忆块中，当启动另一个shell时子shell就可以将父shell中的环境变量所在的记忆块导入到自己的环境变量块中。
7. `read`命令可以读取来自键盘输入的变量  
`read [-pt] 变量名称`  
`-p`：后面可以接提示符  
`-t`:后面可以接等待的“秒数”
8. `declare/typeset`两者都可以声明变量的类型，变量类型默认为字符串类型  
`declare [-aixr] 变量名称`  
`-a`:将后面的变量声明为数组类型  
`-i`:将后面的变量声明为整型  
`-x`:与export一样，将后面的变量变成环境变量  
`-r`:将变量设置成只读类型，该变量不可被更改内容，也不能重设
9. `ulimit`命令可以限制用户的某些系统资源，包括可以打开的文件数量、可以使用的cpu时间、可以使用的内存总量等。想要复原ulimit的设置最简单的方法就是注销再登陆，否则就要以ulimit设置才行，一般身份用户如果以ulimit设置了-f的文件大小，那么他只能继续减少文件容量，不能增加文件容量。
10. 变量内容的删除：  
通配符`*`表示0到无穷个任意字符  
`#`表示符合替换文字的“最短的”那一个  
`##`表示符合替换文字的“最长的”那一个  
以上都是从前面开始删除变量内容，想要从后面往前就得使用`%`，最短的是`%`，最长的是`%%`
11. 变量内容的替换：  
两个斜线`/`之间是旧字符串，后面的是新字符串，如果是两条斜线连着就变成所有符合的内容都会被替代
12. 变量的测试：  
`echo ${old_var-new_var}`  
若变量已存在就使用既有的设置，若不存在就使用新的设置的值，使用`-`不能解决旧的变量被设置为空字符串的情况，而使用`:-`则可以在变量未存在或被设置为空字符串时设置新的值
`-`号的测试并不会影响旧变量的内容，如果我们想要将旧变量内容也一起替换掉的话，那么就使用`=`号。如果旧变量不存在时，整个测试告诉我“有错误”，此时就能够使用问号“`?`”。

### 命令别名与历史命令
1.  命令别名设置：`alias`，`unalias`,命令别名是新创一个新的命令，我们可以直接执行该命令，而变量则需要使用类似“echo”命令才能够调用变量的内容。
2. 历史命令：`history`  
`history [n]`，列出最近的n条命令  
`history [-c]` 将目前shell中的所有history内容全部消除  
`histort [-raw] histfilrs`  
`-a`:将目前的history命令新增入histfiles中，若没有histfiles，默认写入`~/.bash_history`  
`-r`:将histfiles的内容读到目前这个shell的history记忆中  
`-w`:将目前的history记忆写入histfiles中
3. 通过使用`history`命令查询第n条命令，我们可以使用`!n`来执行这条命令，也可以使用`!!`来执行上一条命令

### bash shell的操作环境
1. 命令运行的顺序可以这样看：  
（1）以相对/绝对路径执行命令，例如“/bin/ls”或“./ls”  
（2）由`alias`找到该命令来执行  
（3）由bash内置的(builtin)命令来执行  
（4）通过$PATH这个变量的顺序找到的第一个命令来执行
2. bash的登陆与欢迎信息分别放置在`/etc/issue`和`/etc/motd`这两个文件中，我们可以通过修改这两个文件中的内容得到我们想要显式的信息
3. 取得bash时需要完整的登陆流程的shell就称为login shell，而取得bash接口的方法不需要重复登陆的举动的shell称为non-login shell，这两个取得bash的情况中，读取的配置文件数据并不一样。
4. `/etc/profile`是每个用户登陆取得bash时一定会读取的配置文件，这是系统整体的设置，最好不要修改。而`~/.bash_profile`只有login shell才会读，login shell所读取的个人偏好设置文件其实有三个，依序分别为：  
`~/.bash_profile`、`~/.bash_login`、`~/.profile`其实login shell只会读取上面三个文件中的其中一个，而读取的顺序则是按照上面的顺序。
5. `source`命令可以读入环境配置，利用source命令我们可以直接读取配置文件而不注销登录
6. non-login shell会读取`~./bashrc`，其中包含了用户的个人设置和整体的环境设置，还有其他一些配置文件可能会影响bash的操作，`/etc/man.config`规定了使用man的时候man page的路径到哪里去寻找，`~/.bash_history`存入历史命令记录，`~/.bash_logout`则记录了当我注销bash后系统再帮我做完什么操作才离开
7. 我们可以使用`setty`命令来设置终端机命令行界面的各项参数，包括按键参数，使用`set`命令可以帮我们设置整个命令输出/输入的环境，例如记录历史命令和显示错误内容等。
8. bash中的通配符与特殊符号与正则表达式中的类似，我们可以使用这些通配符和特殊符号更方便的处理数据。

### 数据流重定向
1. 标准输出指的是命令执行所回传的正确的信息，而标准错误输出可理解为命令执行失败后，所回传的错误信息，这两个命令默认都是输出到屏幕上面来，我们可以使用数据流重定向将stdout和stderr分别传送到其他的文件或设备中。
2. 传送所用的特殊字符如下所示：  
（1）标准输入(stdin)：代码为0，使用\<或\<\<  
（2）标准输出(stdout):代码为1，使用\>或\>>  
（3）标准错误输出(stderr):代码为2，使用2\>或2\>\>
3. 重定向文件的创建方式是：  
（1）该文件若不存在，系统会自动将它创建起来  
（2）当这个文件存在的时候，那么系统就会先将这个文件内容清空，然后再将数据写入  
（3）也就是若以\>输出到一个已存在的文件中，那个文件就会被覆盖掉  
如果想要将数据累加而不是将旧的数据删除，使用`>>`符号就好
4. `1>`:以覆盖的方式将正确的数据输出到指定到文件或设备上  
`1>>`:以累加的方式将正确的数据输出到指定到文件或设备上  
`2>`:以覆盖的方式将错误的数据输出到指定到文件或设备上  
`2>>`:以累加的方式将错误的数据输出到指定到文件或设备上  
`1>>`和`2>>`中间是没有空格的
5. 可以将目录定为`/dev/null`，这样错误信息就会被丢弃，因为`/dev/null`可以吃掉任何导向这个设备的信息，如果我们想要把正确数据和错误数据通通写入一个文件，不能像平常写入两个不同文件的写法`find /home -name .bashrc > list 2> list`这样的写法是错误的，因为两条数据同时写入一个文件，又没有特殊的语法，此时两条数据可能会交叉写入该文件内，造成次序的错乱。
6. 为解决上述问题，可以使用`find /home -name .bashrc > list 2>&1`或是`find /home -name .bashrc &> list`
7. 当我们不从键盘输入时，我们可以使用`<`将原本需要由键盘输入的数据改由文件内容来替代，比如`cat > catfile < ~/.bashrc`就是将`~/.bashrc`中的内容写入catfile中，并且可以使用`<<`来获取结束输入符
8. 当我们想要将很多命令一次输入去执行，而不想要分次执行时，可以使用`;`、`&&`和`||`命令，当我们执行的命令之间没有相关性时，我们可以使用`;`，当前一个命令是否成功的执行与后一个命令是否要执行有关，那就得动用到`&&`和`||`
9. `cmd1&&cmd2`：若cmd1执行完毕且正确执行($?=0)，则开始执行cmd2  
                 若cmd1执行完毕且为错误($?≠0)，则cmd2不执行
    `cmd1||cmd2`:若cmd1执行完毕且正确执行($?=0)，则cmd2不执行  
                 若cmd1执行完毕且为错误($?≠0)，则cmd2开始执行
10. 由于命令是一个接着一个去执行的，因此真要使用判断，那么这个`$$`与`||`的顺序就不能搞错。