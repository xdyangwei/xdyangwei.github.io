### 确定你的public继承塑模出is-a关系
1. 如果一个派生类以public形式继承基类，那就是说每个派生类对象同时也是一个基类对象，反之则不成立。只要基类能派生用场的地方，派生类就能派上用场。
2. public继承不改变基类成员的访问权限，子类可以根据基类成员的访问权限进行访问。
3. is-a并非唯一存在于classes之间的关系，另两个常见关系有has-a(有一个)和is-implemented-in-terms-of(根据某物实现出)。
4. public继承意味着is-a，适用于基类上的一定适用于派生类，因为每个派生类对象也都是一个基类对象。

### 避免遮掩继承而来的名称
1. 子类与父类的函数同名时，子类会覆盖掉父类所有的同名函数，如下例，子类的一个func_0，把父类的func_0和func_0(int)都覆盖掉了。
2. 发生覆盖时，父类指针指向子类对象时，访问的全部都是父类的同名成员函数（非虚函数）。
3. 为了解决上述问题，我们可以使用using声明式让基类中的函数在派生类中可见，也可以使用一个转交函数，在转交函数中使用::作用域符直接调用基类中的方法
4. 转交函数的另一个用途是为那些不支持using声明式的老旧编译器另辟一条新路。
5. 派生类的名称会遮掩基类中的名称，在public继承下从来没有人希望如此。

### 区分接口继承和实现继承
1. 我们有时候会希望派生类只继承基类成员函数的接口（也就是声明），有时候希望派生类同时继承函数的接口和实现，但又希望能够override所继承的实现，有时候希望派生类继承函数的接口和实现，并且不允许override任何东西。
2. 以public形式继承的派生类总是会继承成员函数的接口。
3. 纯虚函数有两个最突出的特性：它们必须被任何“继承了它们”的派生类重新声明，而且它们在抽象类中通常没有定义（但是可以为纯虚函数提供定义）。
4. 声明一个纯虚函数的目的是为了让派生类只继承函数接口。
5. 声明（非纯）虚函数的目的是让派生类继承该函数的接口和缺省实现。
6. 声明no-virtual函数的目的是令派生类继承函数的接口和一份强制性实现。

### 考虑virtual函数以外的其他选择
1. 有时候我们需要针对不同的个体采取不同的行为，除了virtual函数之外我们还可以采用一些其他的解决方案。
2. 采用non-virtual interface(NVI)手法，这是template method设计模式的一种特殊形式，它以public non-virtual成员函数包裹较低访问性（private或者protected）的virtual函数。
3. 将virtual函数替换为“函数指针成员变量”，这是strategy设计模式的一种分解表现形式。
4. 以std::function成员变量替换virtual函数，因而允许使用任何callable的对象搭配一个兼容于需求的签名式。这也是strategy设计模式的某种形式。
5. 将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。这是strategy设计模式的传统实现手法。
6. 将机能从成员函数移到class外部函数，带来的一个缺点是非成员函数无法访问class的non-public成员。
7. std::function对象的行为就像一般函数指针，这样的对象可接纳“与给定签名式兼容的”所有可调用物。