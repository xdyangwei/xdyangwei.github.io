### 编译
1. 编译是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码,再转换为机器代码，生成目标文件（.obj）
2. 编译分为两个阶段，分别是编译过程和汇编过程。编译过程又分为预处理阶段和编译、优化阶段。  
预处理阶段：  
（1）宏#define  
（2）条件编译指令，如#ifdef，#ifndef，#else，#elif，#endif等  
（3）头文件包含，#include\<iostream\>  
（4）特殊符号：LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换  
编译优化阶段：  
（1）针对代码优化，不依赖计算机  
（2）针对计算机优化
3. 汇编阶段：把汇编语言代码翻译成目标机器指令，生成目标文件（.o文件、.obj文件）。此过程会依赖机器的硬件和操作系统环境。
4. .o文件至少要提供3张表：  
（1）导出符号表：即该目标文件可以提供的符号及地址   
（2）未解决符号表：即找不到地址的符号的列表，告诉链接器这些符号没找到地址  
（3）地址重定向表：链接的时候，链接器会为目标文件的“未解决符号表”里的符号在其他目标文件中寻找地址，为了区分不同的文件，链接器在链接时就会对每个目标文件的地址进行调整。因为被加上了起始地址，所以符号在自身文件中的实际地址就不对了，需要再用一张地址重定向表记录符号相对自身文件的地址

### 链接
1. 链接程序的主要工作就是将有关的目标文件（库文件、.o文件）彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。
2. 当链接器进行链接的时候，首先决定各个目标文件在最终可执行文件里的位置。然后访问所有目标文件的地址重定义表，对其中记录的地址进行重定向（加上一个偏移量，即该编译单元在可执行文件上的起始地址）。然后遍历所有目标文件的未解决符号表，并且在所有的导出符号表里查找匹配的符号，并在未解决符号表中所记录的位置上填写实现地址。最后把所有的目标文件的内容写在各自的位置上，再作一些另的工作，就生成一个可执行文件。
3. 链接方式：  
（1）静态链接：函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。  
（2）动态链接：函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中
记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。

### 常见注意事项
1. extern：这就是告诉编译器，这个变量或函数在别的编译单元里定义了，也就是要把这个符号放到未解决符号表里面去（外部链接）
2. static：如果该关键字位于全局函数或者变量的声明前面，表明该编译单元不导出这个函数或变量，因些这个符号不能在别的编译单元中使用（内部链接）。如果是static局部变量，则该变量的存储方式和全局变量一样，但是仍然不导出符号。
3. 默认链接属性：对于函数和变量，默认链接是外部链接，对于const变量，默认内部链接。
4. 外部链接的利弊：外部链接的符号在整个程序范围内都是可以使用的，这就要求其他编译单元不能导出相同的符号（不然就会报 duplicated external symbols）。
5. 为什么头文件里一般只可以有声明不能有定义：头文件可以被多个编译单元包含，如果头文件里面有定义的话，那么每个包含这头文件的编译单元都会对同一个符号进行定义，如果该符号为外部链接，则会导致duplicated external symbols链接错误。
6. 为什么公共使用的内联函数要定义于头文件里：因为编译时编译单元之间互不知道，如果内联被定义于.cpp文件中，编译其他使用该函数的编译单元的时候没有办法找到函数的定义，因些无法对函数进行展开（内联函数不展开，即不采用在使用处标记函数代码再跳转的方式，而是直接将代码嵌入）。所以如果内联函数定义于.cpp里，那么就只有这个.cpp文件能使用它。
7. .h中的inline 函数可以被多个cpp包含而不造成符号冲突，因为它会被直接嵌入到调用的地方，内部联结不形成外部符号,对外不可见
8. 为什么类的静态数据成员不可以就地初始化：因为类体一般是放在头文件中的，如果允许其静态成员就地初始化，那就相当于允许在头文件中定义变量了。