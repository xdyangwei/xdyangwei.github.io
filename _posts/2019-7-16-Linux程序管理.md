### 进程
1. 触发任何一个事件时，系统都会将它定义成为一个进程，并且给与这个进程一个ID，称为PID，同时依据触发这个进程的用户与相关属性关系，给与这个PID一组有效的权限设置。
2. 进程有给与执行者的权限/属性等参数，并包括进程所需要的脚本与数据或文件数据等，最后再给与一个PID，系统就是通过这个PID来判断该process是否具有权限进行工作的。
3. 由父进程衍生出来的其他进程在一般状态下，也会沿用这个进程的相关权限。
4. **程序**：通常为二进制程序放置在存储媒介中，以物理文件的形式存在  
**进程**：程序被触发后，执行者的权限与属性、程序的程序代码与所需数据等都会被加载到内存中，操作系统并给予这个内存内的单元一个标识符(PID),进程就是一个正在运行中的程序。
5. 某个进程的父进程可以通过Parent PID(PPID)来判断。进程都会通过父进程以复制(fork)方式产生一个一模一样的子进程，然后被复制出来的子进程再以exec的方式执行实际要进行的进程，最终成为一个子进程的存在。
6. 常驻进程被称为服务(daemon)，使用`&`符号可以让某个命令放置于后台执行。

### 工作管理
1. bash环境下工作管理是当我们登陆系统取得bash shell之后，在单一终端机下同时进行多个工作的行为管理。在进行工作管理的行为中，其实每个工作都是都是目前bash的子进程，即彼此之间是有相关性的，我们无法以job control的方式由tty1的环境去管理tty2的bash。
2. 要进行bash的job control必须要注意的限制是：  
（1）这些工作所触发的进程必须来自于我们shell的子进程(只管理自己的bash)  
（2）前台：我们可以控制与执行命令的这个环境称为前台的工作  
（3）可以自行运行的工作，我们无法使用ctrl+c终止它，可使用bg/fg调用该工作  
（4）后台中“执行”的进程不能等待terminate/shell的输入
3. `&`命令可以直接将命令丢到后台中“执行”，但是如果执行过程中出现错误信息，则会输出到前台影响前台，因此我们可以使用数据流重定向将输出信息输出到某个文件中。
4. 工作号码(job number)只与bash环境有关，但是它是由命令触发因此也会搭配一个PID。
5. `ctrl+z`可以将目前的工作丢到后台中“暂停”，`+`代表最近一个被丢进后台的工作，且目前在后台下默认会被取用的那个工作(与`fg`命令有关)，而`stopped`则代表目前这个工作的状态，在默认情况下使用`ctrl+z`丢到后台当中的工作都是“暂停”的状态
6. `jobs`命令可以查看目前的后台工作状态，`+`代表默认的取用工作，如果我们仅输入`fg`，那么[2]所代表的的工作会被拿到前台当中处理，`-`代表最近最后第二个被放置到后台中的工作号码，而当超过最后三个以后的工作时就没有`+-`符号了。  
`jobs [-lrs]`  
`-l`:除了列出job number与命令串以外，同时列出PID的号码  
`-r`:仅列出正在后台run的工作  
`-s`:仅列出正在后台暂停的工作
7. `fg`命令可以将后台工作拿到前台来处理  
`fg %jobnumber`:jobnumber为工作号码，%是可有可无的，如果不加jobnumber默认为最近的一个工作
8. `bg`命令可以让工作在后台下的状态变成运行中，`kill`命令可以管理后台当中的工作。  
`kill -l`:列出目前`kill`能够使用的信号有哪些  
`kill -signal %jobnumber`  
`-1`:重新读取一次参数的配置文件  
`-2`:代表与由键盘输入`ctrl+c`同样的操作  
`-9`:立即强制删除一个工作  
`-15`:以正常的程序方式终止一项工作，与-9不一样  
`-9`通常是在强制删除一个不正常的工作时使用的，`-15`则是以正常步骤结束一项工作(15是默认值)
9. `kill`后面接的数字默认是PID，如果想要管理bash的工作控制就要加上%数字了。如果想要进行脱机管理，我们可以使用`nohup [命令与参数]`让工作在终端机前台工作，也可以使用`nohup [命令与参数] &`让工作在终端机后台工作。