### 分组统计
1. 如果需要获取表中一部分行的统计值需要使用`GROUP BY`子句，`GROUP BY`子句在生成结果集时生成多个分类汇总
2. 如果使用了`GROUP BY`子句进行分组查询，`SELECT`查询的列必须包含在`GROUP BY`子句中或者包含在聚合函数中
3. 执行含有`GROUP BY`子句的`SELECT`查询的步骤：  
（1）数据库系统首先执行`FROM`子句  
（2）如果在`SELECT`查询中存在`WHERE`子句，那么根据其中的条件，从结果集中筛选出比较结果为`FALSE`的行  
（3）根据`GROUP BY`子句指定的分组字段将结果集进行分组  
（4）最后根据`SELECT`子句的值为每组生成查询结果中的一行
4. `GROUP BY`子句可以根据多列进行分组且数目没有上限，唯一的限制是组合列必须是查询数据表中的列
5. 如果在`GROUP BY`子句中使用的字段的别名会出现错误因为执行`GROUP BY`子句之前还没有执行`SELECT`子句，为了解决这个问题可以使用子查询
6. 在`GROUP BY`子句中使用表达式时，用到的字段必须是相同数据类型的，否则会出现错误
7. `GROUP BY`子句中可以使用`ROLLUP`关键字对字段的几种可能性进行分组，使用`ROLLUP(A,B,C)`系统首先对A、B、C进行分组操作，然后对A和B进行分组操作，之后对A进行分组操作，最后对全表进行分组操作，在SQL Server中还能使用`WITH ROLLUP`关键字
8. `CUBE`关键字与`ROLLUP`关键字作用相同，在SQL Server中还能使用`WITH CUBE`关键字
9. `WHERE`子句和`HAVING`子句主要区别如下：  
（1）`WHERE`不能放在`GROUP BY`后面，而`HAVING`可以  
（2）`HAVING`是与`GROUP BY`连在一起使用的，放在`GROUP BY`后面，此时的作用相当于`WHERE`子句  
（3）`WHERE`后面的条件里不能有聚合函数，而`HAVING`子句可以  
总的来说，`WHERE`子句在数据分组前进行过滤，而`HAVING`子句在数据分组后进行过滤

### 简单子查询
1. 子查询的语法与普通的`SELECT`查询的语法相同，子查询可以包含联合、`WHERE`子句、`HAVING`子句和`GROUP BY`子句
2. 子查询的语法规则如下：  
（1）子查询的`SELECT`必须使用圆括号括起来  
（2）不能包括`COMPUTE或FOR BROWSE子句`  
（3）如果同时指定`TOP`子句，则可能只包括`ORDER BY`子句  
（4）子查询最多可以嵌套32层  
（5）任何可以使用表达式的地方都可以使用子查询，只要它返回的是单个值  
（6）如果某个表只出现在子查询中而不出现在外部查询中，那么该表中的列就无法包含在输出中
3. 子查询与其他`SELECT`语句之间的区别：  
（1）子查询不仅可以使用子查询`FROM`子句中的表，还可以使用子查询`FROM`子句中表的任何列  
（2）子查询必须返回单一数据列  
（3）子查询不能有`ORDER BY`子句  
（4）子查询必须由一个`SELECT`语句组成，不能将多个`SQL语句`用`UNION`组合起来作为一个子查询
4. 聚合函数都返回单个值，在子查询中应用聚合函数，并将该函数返回的结果应用到`WHERE`子句的查询条件中

### 多行子查询
1. `IN子查询`是指在外层查询和子查询之间用`IN`连接，判断某个属性列是否在子查询的结果中，其返回的结果中可以包含零个或者多个值，要是想达成相反的效果可以使用`NOT IN子查询`
2. `EXISTS子查询`的功能是判断子查询的返回结果中是否有数据行，如果子查询返回的结果是空集则`EXISTS`失败，`NOT EXISTS`成功
3. 一些带`EXISTS`或者`EXISTS`的子查询不能被其他形式的子查询等价替换，但所有带`IN、ANY、ALL`和比较运算符的子查询都能用带`EXISTS`的子查询等价替换
4. `SOME、ANY、ALL`是量词，允许将比较运算符左边的单值与生成单列但多行结果集的子查询相比较。

### 多表连接
1. 