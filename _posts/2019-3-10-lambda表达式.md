### lambda表达式的作用
1. 没有lambda表达式，STL中的“_if”族算法（比如std::find_if、std::remove_if和std::count_if等）恐怕只能使用最平凡的谓词来调用，这种情况同样发生在能够自定义比较函数的算法族（比如std::sort、std::nth_element和std::lower_bound等）。
2. lambda表达式也能够用来为std::unique_ptr和std::shared_ptr快速创建自定义析构器，还能以同样直接的程度对谓词做特化处理来提供条件变量给线程API。
3. 标准库之外，lambda表达式可以临时制作出回调函数、接口适配函数或是语境相关函数的特化版本以供一次性调用。
4. 闭包是lambda式创建的运行期对象，根据不同的捕获模式，闭包会持有数据的副本或引用。闭包类就是实例化闭包的类。每个lambda表达式都会触发编译器生成一个独一无二的闭包类。而闭包中的语句会变成它的闭包类成员函数的可执行指令。
5. lambda表达式常用于创建闭包并仅将其传递给函数的实参。一般而言，闭包可以复制，因此对于一个单独的闭包类别可以有多个闭包。

### 避免默认捕获模式

1. C++11中有两种默认捕获模式，按引用或按值。按引用的默认捕获模式可能会导致空悬引用，按值的默认捕获模式貌似对空悬引用免疫，但是并没有，还会让我们认为自己的闭包是独立的（事实上它们可能不是独立的）。
2. 按引用捕获会导致闭包包含指向局部变量的引用，或者指向定义lambda表达式内作用域形参的引用。一旦由lambda表达式所创建的闭包越过了该局部变量或形参的生命期，那么闭包内的引用就会空悬。
3. 从长远观点来看，显式地列出lambda表达式所依赖的局部变量或形参是更好的软件工程实践，因为这样可以比较明显地看出是否有引用指向局部变量生命期过后导致空悬。
4. 解决空悬引用的一个方法是采用按值的默认捕获模式，但是按值捕获了一个指针以后，在lambda闭包中持有的是这个指针的副本，但是我们无法阻止lambda以外的代码去针对该指针实施delete操作导致lambda表达室内的指针副本空悬。
5. 捕获只能针对于在创建lambda式的作用域内可见的非静态局部变量（包括形参）。每一个非静态成员函数都持有一个this指针，然后每当提及该类的成员变量时都会用到该指针，因此成员函数内lambda闭包的存活与它含有其this指针副本的类对象的生命期是绑在一起的。这一特定问题可以通过将我们想捕获的成员变量复制到局部变量中，然后捕获该局部副本加以解决。
6. 在C++14中，捕获成员变量的一种更好的方法是使用广义lambda捕获，对于广义lambda捕获而言没有按默认模式捕获一说。
7. 使用默认值捕获模式的另外一个缺点是在于它似乎表明闭包是自洽的，与闭包外的数据变化绝缘，但是一般来说这是不正确的，因为lambda表达式不仅依赖于局部变量和形参（它们可以被捕获），它们还会依赖于静态存储期对象，这样的对象可以在lambda式内使用但是不能被捕获。此时如果使用了按默认值捕获模式，这些对象就给人错觉感觉是可以被捕获的。