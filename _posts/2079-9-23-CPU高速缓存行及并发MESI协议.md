### CPU缓存和缓存行
1. CPU缓存、总线与内存关系：  
**CPU Cache --> 前端总线 FSB --> Memory 内存**
2. CPU 为了更快的执行代码。于是当从内存中读取数据时，并不是只读自己想要的部分。而是读取足够的字节来填入高速缓存行。这样，当 CPU 访问相邻的数据时，就不必每次都从内存中读取，提高了速度。 因为访问内存要比访问高速缓存用的时间多得多
3. 前端总线——Front Side Bus（FSB），是将CPU连接到北桥芯片的总线。前端总线（FSB）就是负责将CPU连接到内存的一座桥，前端总线频率则直接影响CPU与内存数据交换速度，如果FSB频率越高，说明这座桥越宽，可以同时通过的车辆越多，这样CPU处理的速度就更快。前端总线频率越高，CPU与内存之间的数据传输量越大
4. Cache Line可以简单的理解为CPU Cache中的最小缓存单位。目前主流的CPU Cache的Cache Line大小都是64Bytes。假设我们有一个512字节的一级缓存，那么按照64B的缓存单位大小来算，这个一级缓存所能存放的缓存个数就是512/64 = 8个
5. 当数组小于64Bytes时数组极有可能落在一条Cache Line内，而一个元素的访问就会使得整条Cache Line被填充，因而值得后面的若干个元素受益于缓存带来的加速。而当数组大于64Bytes时，必然至少需要两条Cache Line，继而在循环访问时会出现两次Cache Line的填充，由于缓存填充的时间远高于数据访问的响应时间，因此多一次缓存填充对于总执行的影响会被放大
6. 为了解决并发读写问题，芯片设计者制定了一个规则。当一个 CPU 修改高速缓存行中的字节时，计算机中的其它CPU会被通知，它们的高速缓存将视为无效。于是，在上面的情况下，CPU2发现自己的高速缓存中数据已无效，CPU1将立即把自己的数据写回RAM ，然后CPU2重新读取该数据。 可以看出，高速缓存行在多处理器上会导致一些不利

### 多核CPU多级缓存一致性协议MESI
1. MESI 是指4中状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：  
（1）状态：M修改(Modified)  
描述：该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中  
监听任务：缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行  
（2）状态：E 独享、互斥(Exclusive)  
描述：该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中  
监听任务：缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态  
（3）状态：S 共享 (Shared)  
描述：该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中  
监听任务：缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）  
（4）状态：I 无效 (Invalid)  
描述：该Cache line无效  
监听任务：无
2. **对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的，而S状态可能是非一致的。**如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。
3. E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。
4. 缓存的一致性消息传递是要时间的，这就使其切换时会产生延迟。当一个缓存被切换状态时其他缓存收到消息完成各自的切换并且发出回应消息这么一长串的时间中CPU都会等待所有缓存响应完成。可能出现的阻塞都会导致各种各样的性能问题和稳定性问题
5. CPU切换状态阻塞解决-**存储缓存（Store Bufferes）**：  
假如需要修改本地缓存中的一条信息，那么你必须将I（无效）状态通知到其他拥有该缓存数据的CPU缓存中，并且等待确认。等待确认的过程会阻塞处理器，这会降低处理器的性能。应为这个等待远远比一个指令的执行时间长的多。为了避免这种CPU运算能力的浪费，Store Bufferes被引入使用。处理器把它想要写入到主存的值写到缓存，然后继续去处理其他事情。当所有失效确认（Invalidate Acknowledge）都接收到时，数据才会最终被提交
6. Store Bufferes的风险：  
（1）处理器会尝试从存储缓存（Store buffer）中读取值，但它还没有进行提交。这个的解决方案称为Store Forwarding，它使得加载的时候，如果存储缓存中存在，则进行返回  
（2）保存什么时候会完成，这个并没有任何保证