### 名称与声明
1. go中的名称开头是一个字母或下划线，后面可以跟任意数量的字符、数字和下划线，并区分大小写
2. 风格上，当遇到由单词组成的名称时，go程序员一般使用“驼峰式”的风格——更喜欢使用大写字母而不是下划线
3. `var`声明创建一个具体类型的变量，然后给它附加一个名字，设置一个初始值，每一个声明有一个通用的形式：  
    ```
    var name type=expression
    ```
    类型和表达式部分可以省略一个，但是不能都省略。表达式省略的话初始值就是类型的零值
4. 忽略类型使用表达式初始化允许声明多个不同类型的变量。包级别的变量初始化在main函数开始之前进行，局部变量初始化和声明一样在函数执行期间
5. **短变量声明**可以用来声明和初始化局部变量，使用`name:=expression`的形式，变量类型由表达式类型决定。多变量的声明不能和多变量的赋值搞混。
6. 短变量声明不需要声明所有在左边的变量，如果一些变量在同一个词法块中声明，那么对于这些变量，短声明的行为等同于赋值。短变量声明最少声明一个新变量，否则代码编译无法通过
7. 代表变量的表达式，是唯一可以应用取地址符&的表达式。函数返回局部变量的地址是非常安全的。每次都会返回一个不同的值。
8. 另一种创建指针变量的方式是使用内置的new函数，表达式`new(T)`创建一个未命名的T类型变量，初始化为T类型的零值，并返回其地址
9. 每一次调用new返回一个具有唯一地址的不同变量，这个规则有一个例外：**两个变量的类型不携带任何信息且是零值时，例如`struct{}`或`[0]int`，当前的实现里面它们有相同的地址**
10. `new`只是预声明的函数，不是一个关键字，所以它可以重定义为另外的其他类型

### 变量与声明周期
1. 包级别变量的生命周期是整个程序的执行时间，相反局部变量有一个动态的生命周期：执行声明语句时创建一个新的实体，变量一直生存到它变得不可访问，这时它占用的存储空间被回收
2. 因为变量的生命周期是通过它是否可达来确定的，所以局部变量可在包含它的循环的一次迭代之外继续存活。即使包含它的循环已经返回，它的存在还可能延续
3. 编译器可以选择使用堆或栈上的空间来分配，**这个选择不是基于使用var或new关键字来声明变量，而是使用`global`关键字会强制使用堆空间**
4. 多重赋值允许几个变量一次性被赋值，在实际更新变量前，右边所有的表达式被推演，当变量同时出现在赋值符的两侧时特别有用，比如交换变量时：`x,y=y,x`
5. 赋值只有在值对于变量类型是可赋值的时才合法，可赋值性对于不同类型有着不同的规则
6. `type`声明定义一个新的命名类型，它和某个已有类型使用同样的底层类型，命名类型提供了一种方式来区分底层类型的不同或者不兼容使用，这样它们就不会在无意中混用
7. 类型的声明如果是导出的(开头使用大写字母)。其他的包也可以访问它（其他开头大写的导出变量也一样）
8. 对于每个类型T，都有一个对应的类型转换操作`T(x)`将值x转换为类型T，如果两个类型具有相同的底层类型或者二者都是指向相同底层类型变量的未命名指针类型，则二者是可以相互转换的。类型转换不改变类型值的表达方式，仅改变类型
9. 命名类型的底层类型决定了它的结构和表达方式，以及它支持的内部操作集合，这些内部操作与直接使用底层类型的情况相同
10. 命名类型的值可以与其相同类型的值或者底层类型相同的未命名类型的值进行比较，**但是不同命名类型的值不能直接比较，即使他们底层类型一样也不行，需要使用类型转换**
11. 方法名出现在类型的后面表明这个方法关联到这个类型

### 包和文件