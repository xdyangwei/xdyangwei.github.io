### 让接口容易被正确使用，不易被误用
1. 好的接口很容易被正确使用，不容易被误用。我们应该在所有的接口中努力达成这些性质
2. “促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容
3. “阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任
4. shared_ptr支持自定义删除器，这可防范DLL问题，可被用来自动解除互斥锁（mutexes）

### 设计class犹如设计type
1. 定义一个class就是定义了一个新的type，设计优秀的type很艰难，因此设计优秀的class也很不容易。
2. 设计class之前，需要考虑到以下问题：  
（1）新type类型对象的创建与销毁，决定构造函数和析构函数以及内存分配和释放函数  
（2）对象初始化和赋值的行为差别，决定构造函数和赋值操作符  
（3）对象被以值传递，决定拷贝构造函数  
（4）新type的合法值，比如月份class就只有1-12这12个合法值  
（5）新type是否需要继承或被继承，如果被继承则析构函数是否需要为virtual  
（6）新type是否需要转换，决定类型转换函数  
（7）新type需要什么样的操作符和函数  
（8）哪些函数需要被驳回，决定是否声明为private或delete函数  
（9）如何获取新type的成员  
（10）新type的“未声明接口”  
（11）新type是否很一般化通用，如果是就需要考虑定义为一个新的class template  
（12）是否真的需要一个新type
3. class的设计就是type的设计，在定义一个新type之前，确保自己想过上述这些主题。

### 宁以传常量引用替换传值
1. 默认情况下C++以传值方式传递至函数，但是这些副本都是由对象的拷贝构造函数产出，这可能使得传值成为昂贵费时的操作
2. 为了避免传值时可能昂贵的开销，我们可以使用传引用的方式传递，同时为了避免在函数中对原对象进行修改加上const修饰。并且以传引用的方式也可以避免对象切割问题，使用传值传递一个派生类对象实参到一个基类对象形参，派生类部分将会被切割掉。
3. C++编译器底层往往是使用指针来实现引用，因此传引用通常意味着传递的是真正的指针，当对象的类型是内置类型时，传值往往会比传引用效率更高，这个规则同样适用于STL的迭代器和函数对象。
4. 并不是所有小型type都是传值的合格候选人，对象小不代表其copy函数不昂贵，许多对象比如STL中的很多容器内含的东西只比指针多一些，但复制却要复制每一样东西。
5. 并且作为用户自定义类型其大小容易有所变化因此不适合用作传值。