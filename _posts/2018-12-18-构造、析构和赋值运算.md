### 了解C++默默编写并调用哪些函数
1. 如果没有声明任何构造函数，编译器会声明一个默认构造函数，另外如果我们没声明拷贝控制成员的话，编译器会声明一个拷贝构造函数、拷贝赋值函数和一个析构函数。只有当这些函数被需要（被调用），它们才会被编译器创建出来。
2. 编译器创建的析构函数是非虚函数，除非这个类的基类自身声明有虚析构函数。
3. 只有当生出的代码合法且有适当机会证明它有意义，编译器才会生成对应的拷贝构造函数和拷贝赋值函数，比如将引用重新赋值这就属于不合法操作，不会生成构造赋值函数。如果想让这个class支持赋值运算符就必须自己定义拷贝赋值函数。
4. 如果某个基类将拷贝赋值操作符声明为private，编译器将拒绝为其派生类生成拷贝赋值运算符，因为编译器为派生类所生成的拷贝赋值运算符想象中可以处理基类部分，但它们无法调用基类中的这一成员函数因此编译器无能为力。
5. 为了避免编译器自动生成上述函数，可以将相应的成员函数声明为private并且不予实现。使用基类将这些成员函数声明为private，然后再让其他类继承自这个类也能避免这一问题。
### 为多态基类声明virtual析构函数
1. 当派生类对象经由一个基类指针被删除，而该基类带着一个非虚的析构函数，其结果未有定义，通常是对象的派生类部分未被销毁，形成资源泄露。消除这个问题只需要给基类一个虚析构函数。
2. 当一个类不企图当作基类时，将其虚构函数声明为虚函数是个不好的主意，因为实现该虚函数，对象通常需要携带虚函数表指针，vptr指向一个由函数指针构成的数组，称为vtbl，每一个带有虚函数的class都有一个对应的vtbl。当对象调用某一虚函数，实际被调用的函数取决于该对象的vptr指向的那个vtbl——编译器在其寻找适当的函数指针。
3. class的设计目的如果不是作为基类使用或者不是为了具备多态性，就不该声明虚析构函数以免造成更大的开销。
4. 含有纯虚函数的类被称为抽象类，抽象类无法被实例化。
### 别让异常逃离析构函数
1. 析构函数绝对不要抛出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吐下它们（不传播）或结束程序。
2. 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。
### 绝不在构造和析构过程中调用虚函数
1. 在基类对象构造期间，虚函数不是虚函数，只会执行当前基类中的虚函数。如果此时调用的是派生类中虚函数，而派生类中的成员变量尚未初始化，我们不能使用对象内部未初始化的成分，并且在基类构造期间对象类型一直都是基类类型，对象在派生类构造函数开始前不会成为一个派生类对象。
2. 一旦派生类对象析构函数开始执行，对象内的派生类成员变量便呈现未定义值