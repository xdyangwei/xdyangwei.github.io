### 了解隐式接口与编译期多态
1. 面向对象世界编程总是以显式接口和运行期多态解决问题，显式接口在源码中明确可见，虚函数则实现所谓的运行期多态
2. 模板及泛型编程中隐式接口及编译期多态则更为重要，模板中的对象表达式是模板参数必须支持的一组隐式接口，而以不同的template参数具现化函数模板会导致调用不同的函数，这就是所谓的编译期多态。
3. classes和templates都支持接口和多态
4. 对classes而言接口是显式的，以函数签名为中心，多态则是通过virtual函数发生于运行期
5. 对template参数而言，接口是隐式的，奠基于有效表达式。多态则是通过template具现化和函数重载解析发生于编译期。

### 了解typename的双重意义
1. 从C++的角度看，声明template参数时，不论使用关键字class或typename，意义完全相同
2. template内出现的名称如果相依于某个template参数，称之为从属名称，如果从属名称在class内呈嵌套状，我们称它为嵌套从属名称。
3. 如果解析器在template中遭遇一个嵌套从属名称，它便假设这名称不是个类型，除非我们告诉它是。所以缺省情况下嵌套从属名称不是类型。
4. 如果我们想要说明一个嵌套从属名称是一个类型，我们只要在紧邻它之前放置关键字typename即可。任何时候当我们想要在template中指涉一个嵌套从属类型名称，就必须在紧邻它的前一个位置放上关键字typename。
5. typename只被用来验明嵌套从属类型名称，其他名称不该有它的存在。
6. typename不能出现在基类列表内的嵌套从属类型名称之前，也不能出现在成员初始化列表中作为基类修饰符。
7. typedef嵌套从属类型名称时需要在typedef后面加上typename